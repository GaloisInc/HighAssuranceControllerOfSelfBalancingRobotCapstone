//! Implementation for lustre node `Compute` (see [Compute](struct.Compute.html)).
//!
//! Code generated by the [Kind 2 model checker][kind 2].
//!
//! [kind 2]: http://kind2-mc.github.io/kind2/ (The Kind 2 model checker)

// Deactiving lint warnings the transformation does not respect.
#![allow(
  non_upper_case_globals, non_snake_case, non_camel_case_types,
  unused_variables, unused_parens
)]

use helpers::* ;

/// Entry point.
fn main() {
  clap_and_run()
}


/// Stores the state for **top node** `Compute`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `Input` | Real |
/// | `Now` | Real |
/// | `Setpoint` | Real |
/// | `Kp` | Real |
/// | `Ki` | Real |
/// | `Kd` | Real |
/// | `SampleTime` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `Output` | Real |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `Compute_calc` | [Compute_calc](struct.Compute_calc.html) | `Input`, `Now`, `Setpoint`, `Kp`, `Ki`, `Kd`, `SampleTime` | `abs_0` | [pid.lus line 12](../src/lus/pid.lus.html#12) |
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
pub struct Compute {
  /// Input: `Compute.usr.Input`
  pub svar_Input: Real,
  /// Input: `Compute.usr.Now`
  pub svar_Now: Real,
  /// Input: `Compute.usr.Setpoint`
  pub svar_Setpoint: Real,
  /// Input: `Compute.usr.Kp`
  pub svar_Kp: Real,
  /// Input: `Compute.usr.Ki`
  pub svar_Ki: Real,
  /// Input: `Compute.usr.Kd`
  pub svar_Kd: Real,
  /// Input: `Compute.usr.SampleTime`
  pub svar_SampleTime: Real,

  /// Output: `Compute.usr.Output`
  pub svar_Output: Real,

  /// Local, call: `Compute.res.abs_0`
  pub svar_abs_0: Real,

  /// Call to `Compute_calc` ([pid.lus line 12](../src/lus/pid.lus.html#12)).
  pub Compute_calc_0: Compute_calc,
}

impl Sys for Compute {
  type Input = (
    Real, // svar_Input (Compute.usr.Input)
    Real, // svar_Now (Compute.usr.Now)
    Real, // svar_Setpoint (Compute.usr.Setpoint)
    Real, // svar_Kp (Compute.usr.Kp)
    Real, // svar_Ki (Compute.usr.Ki)
    Real, // svar_Kd (Compute.usr.Kd)
    Real, // svar_SampleTime (Compute.usr.SampleTime)
  ) ;
  type Output = (
    Real, // svar_Output (Compute.usr.Output)
  ) ;
  fn arity() -> usize { 7 }
  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
    match vec.len() {
      n if n == Self::arity() => {
        Ok( (
          try!( parse::real(& vec[0]) ), 
          try!( parse::real(& vec[1]) ), 
          try!( parse::real(& vec[2]) ), 
          try!( parse::real(& vec[3]) ), 
          try!( parse::real(& vec[4]) ), 
          try!( parse::real(& vec[5]) ), 
          try!( parse::real(& vec[6]) ),
        ) )
      },
      n => Err(
        format!(
          "arity mismatch, expected {} but got {}: {:?}",
          Self::arity(), n, vec
        )
        
      ),
    }
  }

  fn init(input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_Input = input.0 ;
    let svar_Now = input.1 ;
    let svar_Setpoint = input.2 ;
    let svar_Kp = input.3 ;
    let svar_Ki = input.4 ;
    let svar_Kd = input.5 ;
    let svar_SampleTime = input.6 ;
    
    // |===| Computing initial state.
    let Compute_calc_0 = try!( Compute_calc::init( (
      svar_Input,
      svar_Now,
      svar_Setpoint,
      svar_Kp,
      svar_Ki,
      svar_Kd,
      svar_SampleTime,
    ) ) ) ;
    let (
      svar_abs_0,
    ) = Compute_calc_0.output() ;
    
    let svar_Output = ( if ((svar_Now - 0f64) >= svar_SampleTime) { svar_abs_0 } else {0f64 } ) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Ok( Compute {
      // |===| Inputs.
      svar_Input: svar_Input,
      svar_Now: svar_Now,
      svar_Setpoint: svar_Setpoint,
      svar_Kp: svar_Kp,
      svar_Ki: svar_Ki,
      svar_Kd: svar_Kd,
      svar_SampleTime: svar_SampleTime,
      
      // |===| Outputs.
      svar_Output: svar_Output,
      
      // |===| Locals.
      svar_abs_0: svar_abs_0,
      
      // |===| Calls.
      Compute_calc_0: Compute_calc_0,
    } )
  }

  fn next(mut self, input: Self::Input) -> Result<Self, String> {
    // |===| Retrieving inputs.
    let svar_Input = input.0 ;
    let svar_Now = input.1 ;
    let svar_Setpoint = input.2 ;
    let svar_Kp = input.3 ;
    let svar_Ki = input.4 ;
    let svar_Kd = input.5 ;
    let svar_SampleTime = input.6 ;
    
    // |===| Computing next state.
    let Compute_calc_0 = try!( self.Compute_calc_0.next( (
      svar_Input,
      svar_Now,
      svar_Setpoint,
      svar_Kp,
      svar_Ki,
      svar_Kd,
      svar_SampleTime,
    ) ) ) ;
    let (
      svar_abs_0,
    ) = Compute_calc_0.output() ;
    let svar_Output = ( if ((svar_Now - self.svar_Now) >= svar_SampleTime) { svar_abs_0 } else {self.svar_Output } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_Input = svar_Input ;
    self.svar_Now = svar_Now ;
    self.svar_Setpoint = svar_Setpoint ;
    self.svar_Kp = svar_Kp ;
    self.svar_Ki = svar_Ki ;
    self.svar_Kd = svar_Kd ;
    self.svar_SampleTime = svar_SampleTime ;
    
    // |===| Outputs.
    self.svar_Output = svar_Output ;
    
    // |===| Locals.
    self.svar_abs_0 = svar_abs_0 ;
    
    // |===| Calls.
    self.Compute_calc_0 = Compute_calc_0 ;
    
    // |===| Return new state.
    Ok( self )
  }

  fn output(& self) -> Self::Output {(
    self.svar_Output,
  )}
  fn output_str(& self) -> String {
    format!(
      "{}",
      self.svar_Output
    )
  }
}

/// Stores the state for sub-node `Compute_calc`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `Input` | Real |
/// | `Now` | Real |
/// | `Setpoint` | Real |
/// | `Kp` | Real |
/// | `Ki` | Real |
/// | `Kd` | Real |
/// | `SampleTime` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `Output` | Real |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `limit` | [Limit](struct.Limit.html) | `outputSum` | `abs_0` | [pid.lus line 36](../src/lus/pid.lus.html#36) |
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
pub struct Compute_calc {
  /// Input: `Compute_calc.usr.Input`
  pub svar_Input: Real,
  /// Input: `Compute_calc.usr.Now`
  pub svar_Now: Real,
  /// Input: `Compute_calc.usr.Setpoint`
  pub svar_Setpoint: Real,
  /// Input: `Compute_calc.usr.Kp`
  pub svar_Kp: Real,
  /// Input: `Compute_calc.usr.Ki`
  pub svar_Ki: Real,
  /// Input: `Compute_calc.usr.Kd`
  pub svar_Kd: Real,
  /// Input: `Compute_calc.usr.SampleTime`
  pub svar_SampleTime: Real,

  /// Output: `Compute_calc.usr.Output`
  pub svar_Output: Real,

  /// Local, alias(Compute_calc.impl.usr.outputSum): `Compute_calc.res.abs_0`
  pub svar_abs_0: Real,
  /// Local, local: `Compute_calc.impl.usr.outputSum`
  pub svar_outputSum: Real,
  /// Local, local: `Compute_calc.impl.usr.error`
  pub svar_error: Real,
  /// Local, local: `Compute_calc.impl.usr.dInput`
  pub svar_dInput: Real,

  /// Call to `limit` ([pid.lus line 36](../src/lus/pid.lus.html#36)).
  pub limit_0: Limit,
}

impl Sys for Compute_calc {
  type Input = (
    Real, // svar_Input (Compute_calc.usr.Input)
    Real, // svar_Now (Compute_calc.usr.Now)
    Real, // svar_Setpoint (Compute_calc.usr.Setpoint)
    Real, // svar_Kp (Compute_calc.usr.Kp)
    Real, // svar_Ki (Compute_calc.usr.Ki)
    Real, // svar_Kd (Compute_calc.usr.Kd)
    Real, // svar_SampleTime (Compute_calc.usr.SampleTime)
  ) ;
  type Output = (
    Real, // svar_Output (Compute_calc.usr.Output)
  ) ;
  fn arity() -> usize { 7 }
  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
    match vec.len() {
      n if n == Self::arity() => {
        Ok( (
          try!( parse::real(& vec[0]) ), 
          try!( parse::real(& vec[1]) ), 
          try!( parse::real(& vec[2]) ), 
          try!( parse::real(& vec[3]) ), 
          try!( parse::real(& vec[4]) ), 
          try!( parse::real(& vec[5]) ), 
          try!( parse::real(& vec[6]) ),
        ) )
      },
      n => Err(
        format!(
          "arity mismatch, expected {} but got {}: {:?}",
          Self::arity(), n, vec
        )
        
      ),
    }
  }

