//! Implementation for lustre node `Compute` (see [Compute](struct.Compute.html)).
//!
//! Code generated by the [Kind 2 model checker][kind 2].
//!
//! [kind 2]: http://kind2-mc.github.io/kind2/ (The Kind 2 model checker)

// Deactiving lint warnings the transformation does not respect.
#![allow(
  non_upper_case_globals, non_snake_case, non_camel_case_types,
  unused_variables, unused_parens
)]

#![no_std]

use helpers::* ;

/// Entry point.
fn main() {
  // clap_and_run()
}


/// Stores the state for **top node** `Compute`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `Input` | Real |
/// | `Now` | Real |
/// | `Kp` | Real |
/// | `Kd` | Real |
/// | `Setpoint` | Real |
/// | `SampleTime` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `Output` | Real |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `kmlogic` | [Kmlogic](struct.Kmlogic.html) | `error`, `dInput` | `abs_0` | [fuzzy.lus line 13](../src/lus/fuzzy.lus.html#13) |
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Compute {
  /// Input: `Compute.usr.Input`
  pub svar_Input: Real,
  /// Input: `Compute.usr.Now`
  pub svar_Now: Real,
  /// Input: `Compute.usr.Kp`
  pub svar_Kp: Real,
  /// Input: `Compute.usr.Kd`
  pub svar_Kd: Real,
  /// Input: `Compute.usr.Setpoint`
  pub svar_Setpoint: Real,
  /// Input: `Compute.usr.SampleTime`
  pub svar_SampleTime: Real,

  /// Output: `Compute.usr.Output`
  pub svar_Output: Real,

  /// Local, call: `Compute.res.abs_0`
  pub svar_abs_0: Real,
  /// Local, local: `Compute.impl.usr.error`
  pub svar_error: Real,
  /// Local, local: `Compute.impl.usr.dInput`
  pub svar_dInput: Real,

  /// Call to `kmlogic` ([fuzzy.lus line 13](../src/lus/fuzzy.lus.html#13)).
  pub kmlogic_0: Kmlogic,
}

impl Sys for Compute {
  type Input = (
    Real, // svar_Input (Compute.usr.Input)
    Real, // svar_Now (Compute.usr.Now)
    Real, // svar_Kp (Compute.usr.Kp)
    Real, // svar_Kd (Compute.usr.Kd)
    Real, // svar_Setpoint (Compute.usr.Setpoint)
    Real, // svar_SampleTime (Compute.usr.SampleTime)
  ) ;
  type Output = (
    Real, // svar_Output (Compute.usr.Output)
  ) ;
/*  fn arity() -> usize { 6 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::real(& vec[0]) ), 
              try!( parse::real(& vec[1]) ), 
              try!( parse::real(& vec[2]) ), 
              try!( parse::real(& vec[3]) ), 
              try!( parse::real(& vec[4]) ), 
              try!( parse::real(& vec[5]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_Input = input.0 ;
    let svar_Now = input.1 ;
    let svar_Kp = input.2 ;
    let svar_Kd = input.3 ;
    let svar_Setpoint = input.4 ;
    let svar_SampleTime = input.5 ;
    
    // |===| Computing initial state.
    let svar_error = ((svar_Setpoint - svar_Input) * svar_Kp) ;
    let svar_dInput = ((((svar_Input - 0f64) * 1000f64) / svar_SampleTime) * svar_Kd) ;
    let kmlogic_0 = Kmlogic::init( (
      svar_error,
      svar_dInput,
    ) ) ;
    let (
      svar_abs_0,
    ) = kmlogic_0.output() ;
    
    let svar_Output = ( if ((svar_Now - 0f64) >= svar_SampleTime) { svar_abs_0 } else {0f64 } ) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Compute {
      // |===| Inputs.
      svar_Input: svar_Input,
      svar_Now: svar_Now,
      svar_Kp: svar_Kp,
      svar_Kd: svar_Kd,
      svar_Setpoint: svar_Setpoint,
      svar_SampleTime: svar_SampleTime,
      
      // |===| Outputs.
      svar_Output: svar_Output,
      
      // |===| Locals.
      svar_abs_0: svar_abs_0,
      svar_error: svar_error,
      svar_dInput: svar_dInput,
      
      // |===| Calls.
      kmlogic_0: kmlogic_0,
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_Input = input.0 ;
    let svar_Now = input.1 ;
    let svar_Kp = input.2 ;
    let svar_Kd = input.3 ;
    let svar_Setpoint = input.4 ;
    let svar_SampleTime = input.5 ;
    
    // |===| Computing next state.
    let svar_error = ((svar_Setpoint - svar_Input) * svar_Kp) ;
    let svar_dInput = ((((svar_Input - self.svar_Input) * 1000f64) / svar_SampleTime) * svar_Kd) ;
    /*let kmlogic_0 = */ self.kmlogic_0.next( (
      svar_error,
      svar_dInput,
    ) ) ;
    let (
      svar_abs_0,
    ) = self.kmlogic_0.output() ;
    let svar_Output = ( if ((svar_Now - self.svar_Now) >= svar_SampleTime) { svar_abs_0 } else {self.svar_Output } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_Input = svar_Input ;
    self.svar_Now = svar_Now ;
    self.svar_Kp = svar_Kp ;
    self.svar_Kd = svar_Kd ;
    self.svar_Setpoint = svar_Setpoint ;
    self.svar_SampleTime = svar_SampleTime ;
    
    // |===| Outputs.
    self.svar_Output = svar_Output ;
    
    // |===| Locals.
    self.svar_abs_0 = svar_abs_0 ;
    self.svar_error = svar_error ;
    self.svar_dInput = svar_dInput ;
    
    // |===| Calls.
    /*self.kmlogic_0 = kmlogic_0 ;*/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_Output,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_Output
      )
    }*/
}

/// Stores the state for sub-node `kmlogic`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `pinput` | Real |
/// | `dinput` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `g` | Real |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `dy2fuzzify` | [Dy2fuzzify](struct.Dy2fuzzify.html) | `dlo`, `dinput` | `abs_13` | [fuzzy.lus line 94](../src/lus/fuzzy.lus.html#94) |
/// | `dy1fuzzify` | [Dy1fuzzify](struct.Dy1fuzzify.html) | `dlo`, `dinput` | `abs_12` | [fuzzy.lus line 93](../src/lus/fuzzy.lus.html#93) |
/// | `y2fuzzify` | [Y2fuzzify](struct.Y2fuzzify.html) | `plo`, `pinput` | `abs_11` | [fuzzy.lus line 90](../src/lus/fuzzy.lus.html#90) |
/// | `y1fuzzify` | [Y1fuzzify](struct.Y1fuzzify.html) | `plo`, `pinput` | `abs_10` | [fuzzy.lus line 89](../src/lus/fuzzy.lus.html#89) |
/// | `rule_base` | [Rule_base](struct.Rule_base.html) | `abs_8` | `abs_9` | [fuzzy.lus line 86](../src/lus/fuzzy.lus.html#86) |
/// | `rule_base` | [Rule_base](struct.Rule_base.html) | `abs_6` | `abs_7` | [fuzzy.lus line 85](../src/lus/fuzzy.lus.html#85) |
/// | `rule_base` | [Rule_base](struct.Rule_base.html) | `abs_4` | `abs_5` | [fuzzy.lus line 82](../src/lus/fuzzy.lus.html#82) |
/// | `rule_base` | [Rule_base](struct.Rule_base.html) | `abs_2` | `abs_3` | [fuzzy.lus line 81](../src/lus/fuzzy.lus.html#81) |
/// | `findlocation_d` | [Findlocation_d](struct.Findlocation_d.html) | `dinput` | `abs_1` | [fuzzy.lus line 66](../src/lus/fuzzy.lus.html#66) |
/// | `findlocation_p` | [Findlocation_p](struct.Findlocation_p.html) | `pinput` | `abs_0` | [fuzzy.lus line 65](../src/lus/fuzzy.lus.html#65) |
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Kmlogic {
  /// Input: `kmlogic.usr.pinput`
  pub svar_pinput: Real,
  /// Input: `kmlogic.usr.dinput`
  pub svar_dinput: Real,

  /// Output: `kmlogic.usr.g`
  pub svar_g: Real,

  /// Local, alias(kmlogic.impl.usr.dy2): `kmlogic.res.abs_13`
  pub svar_abs_13: Real,
  /// Local, alias(kmlogic.impl.usr.dy1): `kmlogic.res.abs_12`
  pub svar_abs_12: Real,
  /// Local, alias(kmlogic.impl.usr.py2): `kmlogic.res.abs_11`
  pub svar_abs_11: Real,
  /// Local, alias(kmlogic.impl.usr.py1): `kmlogic.res.abs_10`
  pub svar_abs_10: Real,
  /// Local, alias(kmlogic.impl.usr.second_row_2): `kmlogic.res.abs_9`
  pub svar_abs_9: Real,
  /// Local, invisible local: `kmlogic.res.abs_8`
  pub svar_abs_8: Int,
  /// Local, alias(kmlogic.impl.usr.second_row_1): `kmlogic.res.abs_7`
  pub svar_abs_7: Real,
  /// Local, invisible local: `kmlogic.res.abs_6`
  pub svar_abs_6: Int,
  /// Local, alias(kmlogic.impl.usr.first_row_2): `kmlogic.res.abs_5`
  pub svar_abs_5: Real,
  /// Local, invisible local: `kmlogic.res.abs_4`
  pub svar_abs_4: Int,
  /// Local, alias(kmlogic.impl.usr.first_row_1): `kmlogic.res.abs_3`
  pub svar_abs_3: Real,
  /// Local, invisible local: `kmlogic.res.abs_2`
  pub svar_abs_2: Int,
  /// Local, alias(kmlogic.impl.usr.dlo): `kmlogic.res.abs_1`
  pub svar_abs_1: Int,
  /// Local, alias(kmlogic.impl.usr.plo): `kmlogic.res.abs_0`
  pub svar_abs_0: Int,
  /// Local, local: `kmlogic.impl.usr.dindex2`
  pub svar_dindex2: Int,
  /// Local, local: `kmlogic.impl.usr.dindex1`
  pub svar_dindex1: Int,
  /// Local, local: `kmlogic.impl.usr.dy2`
  pub svar_dy2: Real,
  /// Local, local: `kmlogic.impl.usr.dy1`
  pub svar_dy1: Real,
  /// Local, local: `kmlogic.impl.usr.py2`
  pub svar_py2: Real,
  /// Local, local: `kmlogic.impl.usr.py1`
  pub svar_py1: Real,
  /// Local, local: `kmlogic.impl.usr.second_row_2`
  pub svar_second_row_2: Real,
  /// Local, local: `kmlogic.impl.usr.second_row_1`
  pub svar_second_row_1: Real,
  /// Local, local: `kmlogic.impl.usr.first_row_2`
  pub svar_first_row_2: Real,
  /// Local, local: `kmlogic.impl.usr.first_row_1`
  pub svar_first_row_1: Real,
  /// Local, local: `kmlogic.impl.usr.dloc`
  pub svar_dloc: Int,
  /// Local, local: `kmlogic.impl.usr.ploc_next`
  pub svar_ploc_next: Int,
  /// Local, local: `kmlogic.impl.usr.ploc`
  pub svar_ploc: Int,
  /// Local, local: `kmlogic.impl.usr.dlo`
  pub svar_dlo: Int,
  /// Local, local: `kmlogic.impl.usr.plo`
  pub svar_plo: Int,

  /// Call to `findlocation_p` ([fuzzy.lus line 65](../src/lus/fuzzy.lus.html#65)).
  pub findlocation_p_9: Findlocation_p,
  /// Call to `findlocation_d` ([fuzzy.lus line 66](../src/lus/fuzzy.lus.html#66)).
  pub findlocation_d_8: Findlocation_d,
  /// Call to `rule_base` ([fuzzy.lus line 81](../src/lus/fuzzy.lus.html#81)).
  pub rule_base_7: Rule_base,
  /// Call to `rule_base` ([fuzzy.lus line 82](../src/lus/fuzzy.lus.html#82)).
  pub rule_base_6: Rule_base,
  /// Call to `rule_base` ([fuzzy.lus line 85](../src/lus/fuzzy.lus.html#85)).
  pub rule_base_5: Rule_base,
  /// Call to `rule_base` ([fuzzy.lus line 86](../src/lus/fuzzy.lus.html#86)).
  pub rule_base_4: Rule_base,
  /// Call to `y1fuzzify` ([fuzzy.lus line 89](../src/lus/fuzzy.lus.html#89)).
  pub y1fuzzify_3: Y1fuzzify,
  /// Call to `y2fuzzify` ([fuzzy.lus line 90](../src/lus/fuzzy.lus.html#90)).
  pub y2fuzzify_2: Y2fuzzify,
  /// Call to `dy1fuzzify` ([fuzzy.lus line 93](../src/lus/fuzzy.lus.html#93)).
  pub dy1fuzzify_1: Dy1fuzzify,
  /// Call to `dy2fuzzify` ([fuzzy.lus line 94](../src/lus/fuzzy.lus.html#94)).
  pub dy2fuzzify_0: Dy2fuzzify,
}

impl Sys for Kmlogic {
  type Input = (
    Real, // svar_pinput (kmlogic.usr.pinput)
    Real, // svar_dinput (kmlogic.usr.dinput)
  ) ;
  type Output = (
    Real, // svar_g (kmlogic.usr.g)
  ) ;
/*  fn arity() -> usize { 2 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::real(& vec[0]) ), 
              try!( parse::real(& vec[1]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_pinput = input.0 ;
    let svar_dinput = input.1 ;
    
    // |===| Computing initial state.
    let findlocation_p_9 = Findlocation_p::init( (
      svar_pinput,
    ) ) ;
    let (
      svar_abs_0,
    ) = findlocation_p_9.output() ;
    
    let findlocation_d_8 = Findlocation_d::init( (
      svar_dinput,
    ) ) ;
    let (
      svar_abs_1,
    ) = findlocation_d_8.output() ;
    
    let svar_dlo = svar_abs_1 ;
    let svar_plo = svar_abs_0 ;
    let svar_dloc = ( if (svar_dlo == 0) { 1 } else {( if (svar_dlo == 7) { 6 } else {svar_dlo } ) } ) ;
    let svar_ploc = ( if (svar_plo == 0) { 1 } else {( if (svar_plo == 7) { 6 } else {svar_plo } ) } ) ;
    let svar_dindex1 = (((svar_dloc - 1) * 7) + 1) ;
    let svar_dindex2 = (svar_dindex1 + 7) ;
    let svar_ploc_next = (svar_ploc + 1) ;
    let svar_abs_2 = ((svar_dindex1 + svar_ploc) - 1) ;
    let svar_abs_8 = ((svar_dindex2 + svar_ploc_next) - 1) ;
    let svar_abs_6 = ((svar_dindex2 + svar_ploc) - 1) ;
    let svar_abs_4 = ((svar_dindex1 + svar_ploc_next) - 1) ;
    let rule_base_7 = Rule_base::init( (
      svar_abs_2,
    ) ) ;
    let (
      svar_abs_3,
    ) = rule_base_7.output() ;
    
    let rule_base_6 = Rule_base::init( (
      svar_abs_4,
    ) ) ;
    let (
      svar_abs_5,
    ) = rule_base_6.output() ;
    
    let rule_base_5 = Rule_base::init( (
      svar_abs_6,
    ) ) ;
    let (
      svar_abs_7,
    ) = rule_base_5.output() ;
    
    let rule_base_4 = Rule_base::init( (
      svar_abs_8,
    ) ) ;
    let (
      svar_abs_9,
    ) = rule_base_4.output() ;
    
    let y1fuzzify_3 = Y1fuzzify::init( (
      svar_plo,
      svar_pinput,
    ) ) ;
    let (
      svar_abs_10,
    ) = y1fuzzify_3.output() ;
    
    let y2fuzzify_2 = Y2fuzzify::init( (
      svar_plo,
      svar_pinput,
    ) ) ;
    let (
      svar_abs_11,
    ) = y2fuzzify_2.output() ;
    
    let dy1fuzzify_1 = Dy1fuzzify::init( (
      svar_dlo,
      svar_dinput,
    ) ) ;
    let (
      svar_abs_12,
    ) = dy1fuzzify_1.output() ;
    
    let dy2fuzzify_0 = Dy2fuzzify::init( (
      svar_dlo,
      svar_dinput,
    ) ) ;
    let (
      svar_abs_13,
    ) = dy2fuzzify_0.output() ;
    
    let svar_dy2 = svar_abs_13 ;
    let svar_dy1 = svar_abs_12 ;
    let svar_py2 = svar_abs_11 ;
    let svar_py1 = svar_abs_10 ;
    let svar_second_row_2 = svar_abs_9 ;
    let svar_second_row_1 = svar_abs_7 ;
    let svar_first_row_2 = svar_abs_5 ;
    let svar_first_row_1 = svar_abs_3 ;
    let svar_g = ((svar_dy1 * ((svar_py1 * svar_first_row_1) + (svar_py2 * svar_first_row_2))) + (svar_dy2 * ((svar_py1 * svar_second_row_1) + (svar_py2 * svar_second_row_2)))) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Kmlogic {
      // |===| Inputs.
      svar_pinput: svar_pinput,
      svar_dinput: svar_dinput,
      
      // |===| Outputs.
      svar_g: svar_g,
      
      // |===| Locals.
      svar_abs_13: svar_abs_13,
      svar_abs_12: svar_abs_12,
      svar_abs_11: svar_abs_11,
      svar_abs_10: svar_abs_10,
      svar_abs_9: svar_abs_9,
      svar_abs_8: svar_abs_8,
      svar_abs_7: svar_abs_7,
      svar_abs_6: svar_abs_6,
      svar_abs_5: svar_abs_5,
      svar_abs_4: svar_abs_4,
      svar_abs_3: svar_abs_3,
      svar_abs_2: svar_abs_2,
      svar_abs_1: svar_abs_1,
      svar_abs_0: svar_abs_0,
      svar_dindex2: svar_dindex2,
      svar_dindex1: svar_dindex1,
      svar_dy2: svar_dy2,
      svar_dy1: svar_dy1,
      svar_py2: svar_py2,
      svar_py1: svar_py1,
      svar_second_row_2: svar_second_row_2,
      svar_second_row_1: svar_second_row_1,
      svar_first_row_2: svar_first_row_2,
      svar_first_row_1: svar_first_row_1,
      svar_dloc: svar_dloc,
      svar_ploc_next: svar_ploc_next,
      svar_ploc: svar_ploc,
      svar_dlo: svar_dlo,
      svar_plo: svar_plo,
      
      // |===| Calls.
      findlocation_p_9: findlocation_p_9,
      findlocation_d_8: findlocation_d_8,
      rule_base_7: rule_base_7,
      rule_base_6: rule_base_6,
      rule_base_5: rule_base_5,
      rule_base_4: rule_base_4,
      y1fuzzify_3: y1fuzzify_3,
      y2fuzzify_2: y2fuzzify_2,
      dy1fuzzify_1: dy1fuzzify_1,
      dy2fuzzify_0: dy2fuzzify_0,
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_pinput = input.0 ;
    let svar_dinput = input.1 ;
    
    // |===| Computing next state.
    /*let findlocation_p_9 = */ self.findlocation_p_9.next( (
      svar_pinput,
    ) ) ;
    let (
      svar_abs_0,
    ) = self.findlocation_p_9.output() ;
    /*let findlocation_d_8 = */ self.findlocation_d_8.next( (
      svar_dinput,
    ) ) ;
    let (
      svar_abs_1,
    ) = self.findlocation_d_8.output() ;
    let svar_dlo = svar_abs_1 ;
    let svar_plo = svar_abs_0 ;
    let svar_dloc = ( if (svar_dlo == 0) { 1 } else {( if (svar_dlo == 7) { 6 } else {svar_dlo } ) } ) ;
    let svar_ploc = ( if (svar_plo == 0) { 1 } else {( if (svar_plo == 7) { 6 } else {svar_plo } ) } ) ;
    let svar_dindex1 = (((svar_dloc - 1) * 7) + 1) ;
    let svar_dindex2 = (svar_dindex1 + 7) ;
    let svar_ploc_next = (svar_ploc + 1) ;
    let svar_abs_2 = ((svar_dindex1 + svar_ploc) - 1) ;
    let svar_abs_8 = ((svar_dindex2 + svar_ploc_next) - 1) ;
    let svar_abs_6 = ((svar_dindex2 + svar_ploc) - 1) ;
    let svar_abs_4 = ((svar_dindex1 + svar_ploc_next) - 1) ;
    /*let rule_base_7 = */ self.rule_base_7.next( (
      svar_abs_2,
    ) ) ;
    let (
      svar_abs_3,
    ) = self.rule_base_7.output() ;
    /*let rule_base_6 = */ self.rule_base_6.next( (
      svar_abs_4,
    ) ) ;
    let (
      svar_abs_5,
    ) = self.rule_base_6.output() ;
    /*let rule_base_5 = */ self.rule_base_5.next( (
      svar_abs_6,
    ) ) ;
    let (
      svar_abs_7,
    ) = self.rule_base_5.output() ;
    /*let rule_base_4 = */ self.rule_base_4.next( (
      svar_abs_8,
    ) ) ;
    let (
      svar_abs_9,
    ) = self.rule_base_4.output() ;
    /*let y1fuzzify_3 = */ self.y1fuzzify_3.next( (
      svar_plo,
      svar_pinput,
    ) ) ;
    let (
      svar_abs_10,
    ) = self.y1fuzzify_3.output() ;
    /*let y2fuzzify_2 = */ self.y2fuzzify_2.next( (
      svar_plo,
      svar_pinput,
    ) ) ;
    let (
      svar_abs_11,
    ) = self.y2fuzzify_2.output() ;
    /*let dy1fuzzify_1 = */ self.dy1fuzzify_1.next( (
      svar_dlo,
      svar_dinput,
    ) ) ;
    let (
      svar_abs_12,
    ) = self.dy1fuzzify_1.output() ;
    /*let dy2fuzzify_0 = */ self.dy2fuzzify_0.next( (
      svar_dlo,
      svar_dinput,
    ) ) ;
    let (
      svar_abs_13,
    ) = self.dy2fuzzify_0.output() ;
    let svar_dy2 = svar_abs_13 ;
    let svar_dy1 = svar_abs_12 ;
    let svar_py2 = svar_abs_11 ;
    let svar_py1 = svar_abs_10 ;
    let svar_second_row_2 = svar_abs_9 ;
    let svar_second_row_1 = svar_abs_7 ;
    let svar_first_row_2 = svar_abs_5 ;
    let svar_first_row_1 = svar_abs_3 ;
    let svar_g = ((svar_dy1 * ((svar_py1 * svar_first_row_1) + (svar_py2 * svar_first_row_2))) + (svar_dy2 * ((svar_py1 * svar_second_row_1) + (svar_py2 * svar_second_row_2)))) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_pinput = svar_pinput ;
    self.svar_dinput = svar_dinput ;
    
    // |===| Outputs.
    self.svar_g = svar_g ;
    
    // |===| Locals.
    self.svar_abs_13 = svar_abs_13 ;
    self.svar_abs_12 = svar_abs_12 ;
    self.svar_abs_11 = svar_abs_11 ;
    self.svar_abs_10 = svar_abs_10 ;
    self.svar_abs_9 = svar_abs_9 ;
    self.svar_abs_8 = svar_abs_8 ;
    self.svar_abs_7 = svar_abs_7 ;
    self.svar_abs_6 = svar_abs_6 ;
    self.svar_abs_5 = svar_abs_5 ;
    self.svar_abs_4 = svar_abs_4 ;
    self.svar_abs_3 = svar_abs_3 ;
    self.svar_abs_2 = svar_abs_2 ;
    self.svar_abs_1 = svar_abs_1 ;
    self.svar_abs_0 = svar_abs_0 ;
    self.svar_dindex2 = svar_dindex2 ;
    self.svar_dindex1 = svar_dindex1 ;
    self.svar_dy2 = svar_dy2 ;
    self.svar_dy1 = svar_dy1 ;
    self.svar_py2 = svar_py2 ;
    self.svar_py1 = svar_py1 ;
    self.svar_second_row_2 = svar_second_row_2 ;
    self.svar_second_row_1 = svar_second_row_1 ;
    self.svar_first_row_2 = svar_first_row_2 ;
    self.svar_first_row_1 = svar_first_row_1 ;
    self.svar_dloc = svar_dloc ;
    self.svar_ploc_next = svar_ploc_next ;
    self.svar_ploc = svar_ploc ;
    self.svar_dlo = svar_dlo ;
    self.svar_plo = svar_plo ;
    
    // |===| Calls.
    /*self.findlocation_p_9 = findlocation_p_9 ;
    self.findlocation_d_8 = findlocation_d_8 ;
    self.rule_base_7 = rule_base_7 ;
    self.rule_base_6 = rule_base_6 ;
    self.rule_base_5 = rule_base_5 ;
    self.rule_base_4 = rule_base_4 ;
    self.y1fuzzify_3 = y1fuzzify_3 ;
    self.y2fuzzify_2 = y2fuzzify_2 ;
    self.dy1fuzzify_1 = dy1fuzzify_1 ;
    self.dy2fuzzify_0 = dy2fuzzify_0 ;*/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_g,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_g
      )
    }*/
}

/// Stores the state for sub-node `dy2fuzzify`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `x` | Int |
/// | `input` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Real |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `dy2calc` | [Dy2calc](struct.Dy2calc.html) | `abs_9`, `abs_11`, `input` | `abs_12` | [fuzzy.lus line 262](../src/lus/fuzzy.lus.html#262) |
/// | `dy2calc` | [Dy2calc](struct.Dy2calc.html) | `abs_7`, `abs_9`, `input` | `abs_10` | [fuzzy.lus line 261](../src/lus/fuzzy.lus.html#261) |
/// | `dy2calc` | [Dy2calc](struct.Dy2calc.html) | `abs_5`, `abs_7`, `input` | `abs_8` | [fuzzy.lus line 260](../src/lus/fuzzy.lus.html#260) |
/// | `dy2calc` | [Dy2calc](struct.Dy2calc.html) | `abs_3`, `abs_5`, `input` | `abs_6` | [fuzzy.lus line 259](../src/lus/fuzzy.lus.html#259) |
/// | `dy2calc` | [Dy2calc](struct.Dy2calc.html) | `abs_1`, `abs_3`, `input` | `abs_4` | [fuzzy.lus line 258](../src/lus/fuzzy.lus.html#258) |
/// | `dy2calc` | [Dy2calc](struct.Dy2calc.html) | `abs_0`, `abs_1`, `input` | `abs_2` | [fuzzy.lus line 257](../src/lus/fuzzy.lus.html#257) |
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Dy2fuzzify {
  /// Input: `dy2fuzzify.usr.x`
  pub svar_x: Int,
  /// Input: `dy2fuzzify.usr.input`
  pub svar_input: Real,

  /// Output: `dy2fuzzify.usr.y`
  pub svar_y: Real,

  /// Local, call: `dy2fuzzify.res.abs_12`
  pub svar_abs_12: Real,
  /// Local, invisible local: `dy2fuzzify.res.abs_11`
  pub svar_abs_11: Real,
  /// Local, call: `dy2fuzzify.res.abs_10`
  pub svar_abs_10: Real,
  /// Local, invisible local: `dy2fuzzify.res.abs_9`
  pub svar_abs_9: Real,
  /// Local, call: `dy2fuzzify.res.abs_8`
  pub svar_abs_8: Real,
  /// Local, invisible local: `dy2fuzzify.res.abs_7`
  pub svar_abs_7: Real,
  /// Local, call: `dy2fuzzify.res.abs_6`
  pub svar_abs_6: Real,
  /// Local, invisible local: `dy2fuzzify.res.abs_5`
  pub svar_abs_5: Real,
  /// Local, call: `dy2fuzzify.res.abs_4`
  pub svar_abs_4: Real,
  /// Local, invisible local: `dy2fuzzify.res.abs_3`
  pub svar_abs_3: Real,
  /// Local, call: `dy2fuzzify.res.abs_2`
  pub svar_abs_2: Real,
  /// Local, invisible local: `dy2fuzzify.res.abs_1`
  pub svar_abs_1: Real,
  /// Local, invisible local: `dy2fuzzify.res.abs_0`
  pub svar_abs_0: Real,

  /// Call to `dy2calc` ([fuzzy.lus line 257](../src/lus/fuzzy.lus.html#257)).
  pub dy2calc_5: Dy2calc,
  /// Call to `dy2calc` ([fuzzy.lus line 258](../src/lus/fuzzy.lus.html#258)).
  pub dy2calc_4: Dy2calc,
  /// Call to `dy2calc` ([fuzzy.lus line 259](../src/lus/fuzzy.lus.html#259)).
  pub dy2calc_3: Dy2calc,
  /// Call to `dy2calc` ([fuzzy.lus line 260](../src/lus/fuzzy.lus.html#260)).
  pub dy2calc_2: Dy2calc,
  /// Call to `dy2calc` ([fuzzy.lus line 261](../src/lus/fuzzy.lus.html#261)).
  pub dy2calc_1: Dy2calc,
  /// Call to `dy2calc` ([fuzzy.lus line 262](../src/lus/fuzzy.lus.html#262)).
  pub dy2calc_0: Dy2calc,
}

impl Sys for Dy2fuzzify {
  type Input = (
    Int, // svar_x (dy2fuzzify.usr.x)
    Real, // svar_input (dy2fuzzify.usr.input)
  ) ;
  type Output = (
    Real, // svar_y (dy2fuzzify.usr.y)
  ) ;
/*  fn arity() -> usize { 2 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::int(& vec[0]) ), 
              try!( parse::real(& vec[1]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    let svar_input = input.1 ;
    
    // |===| Computing initial state.
    let svar_abs_9 = - (1f64 * - 3f64 / 10f64) ;
    let svar_abs_11 = - (1f64 * - 1f64) ;
    let svar_abs_7 = - (1f64 * - 1f64 / 10f64) ;
    let svar_abs_3 = - 1f64 / 10f64 ;
    let svar_abs_1 = - 3f64 / 10f64 ;
    let svar_abs_0 = - 1f64 ;
    let svar_abs_5 = 0f64 ;
    let dy2calc_5 = Dy2calc::init( (
      svar_abs_0,
      svar_abs_1,
      svar_input,
    ) ) ;
    let (
      svar_abs_2,
    ) = dy2calc_5.output() ;
    
    let dy2calc_4 = Dy2calc::init( (
      svar_abs_1,
      svar_abs_3,
      svar_input,
    ) ) ;
    let (
      svar_abs_4,
    ) = dy2calc_4.output() ;
    
    let dy2calc_3 = Dy2calc::init( (
      svar_abs_3,
      svar_abs_5,
      svar_input,
    ) ) ;
    let (
      svar_abs_6,
    ) = dy2calc_3.output() ;
    
    let dy2calc_2 = Dy2calc::init( (
      svar_abs_5,
      svar_abs_7,
      svar_input,
    ) ) ;
    let (
      svar_abs_8,
    ) = dy2calc_2.output() ;
    
    let dy2calc_1 = Dy2calc::init( (
      svar_abs_7,
      svar_abs_9,
      svar_input,
    ) ) ;
    let (
      svar_abs_10,
    ) = dy2calc_1.output() ;
    
    let dy2calc_0 = Dy2calc::init( (
      svar_abs_9,
      svar_abs_11,
      svar_input,
    ) ) ;
    let (
      svar_abs_12,
    ) = dy2calc_0.output() ;
    
    let svar_y = ( if (svar_x == 0) { 0f64 } else {( if (svar_x == 1) { svar_abs_2 } else {( if (svar_x == 2) { svar_abs_4 } else {( if (svar_x == 3) { svar_abs_6 } else {( if (svar_x == 4) { svar_abs_8 } else {( if (svar_x == 5) { svar_abs_10 } else {( if (svar_x == 6) { svar_abs_12 } else {1f64 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Dy2fuzzify {
      // |===| Inputs.
      svar_x: svar_x,
      svar_input: svar_input,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      svar_abs_12: svar_abs_12,
      svar_abs_11: svar_abs_11,
      svar_abs_10: svar_abs_10,
      svar_abs_9: svar_abs_9,
      svar_abs_8: svar_abs_8,
      svar_abs_7: svar_abs_7,
      svar_abs_6: svar_abs_6,
      svar_abs_5: svar_abs_5,
      svar_abs_4: svar_abs_4,
      svar_abs_3: svar_abs_3,
      svar_abs_2: svar_abs_2,
      svar_abs_1: svar_abs_1,
      svar_abs_0: svar_abs_0,
      
      // |===| Calls.
      dy2calc_5: dy2calc_5,
      dy2calc_4: dy2calc_4,
      dy2calc_3: dy2calc_3,
      dy2calc_2: dy2calc_2,
      dy2calc_1: dy2calc_1,
      dy2calc_0: dy2calc_0,
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    let svar_input = input.1 ;
    
    // |===| Computing next state.
    let svar_abs_9 = - (1f64 * - 3f64 / 10f64) ;
    let svar_abs_11 = - (1f64 * - 1f64) ;
    let svar_abs_7 = - (1f64 * - 1f64 / 10f64) ;
    let svar_abs_3 = - 1f64 / 10f64 ;
    let svar_abs_1 = - 3f64 / 10f64 ;
    let svar_abs_0 = - 1f64 ;
    let svar_abs_5 = 0f64 ;
    /*let dy2calc_5 = */ self.dy2calc_5.next( (
      svar_abs_0,
      svar_abs_1,
      svar_input,
    ) ) ;
    let (
      svar_abs_2,
    ) = self.dy2calc_5.output() ;
    /*let dy2calc_4 = */ self.dy2calc_4.next( (
      svar_abs_1,
      svar_abs_3,
      svar_input,
    ) ) ;
    let (
      svar_abs_4,
    ) = self.dy2calc_4.output() ;
    /*let dy2calc_3 = */ self.dy2calc_3.next( (
      svar_abs_3,
      svar_abs_5,
      svar_input,
    ) ) ;
    let (
      svar_abs_6,
    ) = self.dy2calc_3.output() ;
    /*let dy2calc_2 = */ self.dy2calc_2.next( (
      svar_abs_5,
      svar_abs_7,
      svar_input,
    ) ) ;
    let (
      svar_abs_8,
    ) = self.dy2calc_2.output() ;
    /*let dy2calc_1 = */ self.dy2calc_1.next( (
      svar_abs_7,
      svar_abs_9,
      svar_input,
    ) ) ;
    let (
      svar_abs_10,
    ) = self.dy2calc_1.output() ;
    /*let dy2calc_0 = */ self.dy2calc_0.next( (
      svar_abs_9,
      svar_abs_11,
      svar_input,
    ) ) ;
    let (
      svar_abs_12,
    ) = self.dy2calc_0.output() ;
    let svar_y = ( if (svar_x == 0) { 0f64 } else {( if (svar_x == 1) { svar_abs_2 } else {( if (svar_x == 2) { svar_abs_4 } else {( if (svar_x == 3) { svar_abs_6 } else {( if (svar_x == 4) { svar_abs_8 } else {( if (svar_x == 5) { svar_abs_10 } else {( if (svar_x == 6) { svar_abs_12 } else {1f64 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_x = svar_x ;
    self.svar_input = svar_input ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    self.svar_abs_12 = svar_abs_12 ;
    self.svar_abs_11 = svar_abs_11 ;
    self.svar_abs_10 = svar_abs_10 ;
    self.svar_abs_9 = svar_abs_9 ;
    self.svar_abs_8 = svar_abs_8 ;
    self.svar_abs_7 = svar_abs_7 ;
    self.svar_abs_6 = svar_abs_6 ;
    self.svar_abs_5 = svar_abs_5 ;
    self.svar_abs_4 = svar_abs_4 ;
    self.svar_abs_3 = svar_abs_3 ;
    self.svar_abs_2 = svar_abs_2 ;
    self.svar_abs_1 = svar_abs_1 ;
    self.svar_abs_0 = svar_abs_0 ;
    
    // |===| Calls.
    /*self.dy2calc_5 = dy2calc_5 ;
    self.dy2calc_4 = dy2calc_4 ;
    self.dy2calc_3 = dy2calc_3 ;
    self.dy2calc_2 = dy2calc_2 ;
    self.dy2calc_1 = dy2calc_1 ;
    self.dy2calc_0 = dy2calc_0 ;*/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `dy1fuzzify`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `x` | Int |
/// | `input` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Real |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `dy1calc` | [Dy1calc](struct.Dy1calc.html) | `abs_9`, `abs_11`, `input` | `abs_12` | [fuzzy.lus line 243](../src/lus/fuzzy.lus.html#243) |
/// | `dy1calc` | [Dy1calc](struct.Dy1calc.html) | `abs_7`, `abs_9`, `input` | `abs_10` | [fuzzy.lus line 242](../src/lus/fuzzy.lus.html#242) |
/// | `dy1calc` | [Dy1calc](struct.Dy1calc.html) | `abs_5`, `abs_7`, `input` | `abs_8` | [fuzzy.lus line 241](../src/lus/fuzzy.lus.html#241) |
/// | `dy1calc` | [Dy1calc](struct.Dy1calc.html) | `abs_3`, `abs_5`, `input` | `abs_6` | [fuzzy.lus line 240](../src/lus/fuzzy.lus.html#240) |
/// | `dy1calc` | [Dy1calc](struct.Dy1calc.html) | `abs_1`, `abs_3`, `input` | `abs_4` | [fuzzy.lus line 239](../src/lus/fuzzy.lus.html#239) |
/// | `dy1calc` | [Dy1calc](struct.Dy1calc.html) | `abs_0`, `abs_1`, `input` | `abs_2` | [fuzzy.lus line 238](../src/lus/fuzzy.lus.html#238) |
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Dy1fuzzify {
  /// Input: `dy1fuzzify.usr.x`
  pub svar_x: Int,
  /// Input: `dy1fuzzify.usr.input`
  pub svar_input: Real,

  /// Output: `dy1fuzzify.usr.y`
  pub svar_y: Real,

  /// Local, call: `dy1fuzzify.res.abs_12`
  pub svar_abs_12: Real,
  /// Local, invisible local: `dy1fuzzify.res.abs_11`
  pub svar_abs_11: Real,
  /// Local, call: `dy1fuzzify.res.abs_10`
  pub svar_abs_10: Real,
  /// Local, invisible local: `dy1fuzzify.res.abs_9`
  pub svar_abs_9: Real,
  /// Local, call: `dy1fuzzify.res.abs_8`
  pub svar_abs_8: Real,
  /// Local, invisible local: `dy1fuzzify.res.abs_7`
  pub svar_abs_7: Real,
  /// Local, call: `dy1fuzzify.res.abs_6`
  pub svar_abs_6: Real,
  /// Local, invisible local: `dy1fuzzify.res.abs_5`
  pub svar_abs_5: Real,
  /// Local, call: `dy1fuzzify.res.abs_4`
  pub svar_abs_4: Real,
  /// Local, invisible local: `dy1fuzzify.res.abs_3`
  pub svar_abs_3: Real,
  /// Local, call: `dy1fuzzify.res.abs_2`
  pub svar_abs_2: Real,
  /// Local, invisible local: `dy1fuzzify.res.abs_1`
  pub svar_abs_1: Real,
  /// Local, invisible local: `dy1fuzzify.res.abs_0`
  pub svar_abs_0: Real,

  /// Call to `dy1calc` ([fuzzy.lus line 238](../src/lus/fuzzy.lus.html#238)).
  pub dy1calc_5: Dy1calc,
  /// Call to `dy1calc` ([fuzzy.lus line 239](../src/lus/fuzzy.lus.html#239)).
  pub dy1calc_4: Dy1calc,
  /// Call to `dy1calc` ([fuzzy.lus line 240](../src/lus/fuzzy.lus.html#240)).
  pub dy1calc_3: Dy1calc,
  /// Call to `dy1calc` ([fuzzy.lus line 241](../src/lus/fuzzy.lus.html#241)).
  pub dy1calc_2: Dy1calc,
  /// Call to `dy1calc` ([fuzzy.lus line 242](../src/lus/fuzzy.lus.html#242)).
  pub dy1calc_1: Dy1calc,
  /// Call to `dy1calc` ([fuzzy.lus line 243](../src/lus/fuzzy.lus.html#243)).
  pub dy1calc_0: Dy1calc,
}

impl Sys for Dy1fuzzify {
  type Input = (
    Int, // svar_x (dy1fuzzify.usr.x)
    Real, // svar_input (dy1fuzzify.usr.input)
  ) ;
  type Output = (
    Real, // svar_y (dy1fuzzify.usr.y)
  ) ;
/*  fn arity() -> usize { 2 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::int(& vec[0]) ), 
              try!( parse::real(& vec[1]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    let svar_input = input.1 ;
    
    // |===| Computing initial state.
    let svar_abs_9 = - (1f64 * - 3f64 / 10f64) ;
    let svar_abs_11 = - (1f64 * - 1f64) ;
    let svar_abs_7 = - (1f64 * - 1f64 / 10f64) ;
    let svar_abs_3 = - 1f64 / 10f64 ;
    let svar_abs_1 = - 3f64 / 10f64 ;
    let svar_abs_0 = - 1f64 ;
    let svar_abs_5 = 0f64 ;
    let dy1calc_5 = Dy1calc::init( (
      svar_abs_0,
      svar_abs_1,
      svar_input,
    ) ) ;
    let (
      svar_abs_2,
    ) = dy1calc_5.output() ;
    
    let dy1calc_4 = Dy1calc::init( (
      svar_abs_1,
      svar_abs_3,
      svar_input,
    ) ) ;
    let (
      svar_abs_4,
    ) = dy1calc_4.output() ;
    
    let dy1calc_3 = Dy1calc::init( (
      svar_abs_3,
      svar_abs_5,
      svar_input,
    ) ) ;
    let (
      svar_abs_6,
    ) = dy1calc_3.output() ;
    
    let dy1calc_2 = Dy1calc::init( (
      svar_abs_5,
      svar_abs_7,
      svar_input,
    ) ) ;
    let (
      svar_abs_8,
    ) = dy1calc_2.output() ;
    
    let dy1calc_1 = Dy1calc::init( (
      svar_abs_7,
      svar_abs_9,
      svar_input,
    ) ) ;
    let (
      svar_abs_10,
    ) = dy1calc_1.output() ;
    
    let dy1calc_0 = Dy1calc::init( (
      svar_abs_9,
      svar_abs_11,
      svar_input,
    ) ) ;
    let (
      svar_abs_12,
    ) = dy1calc_0.output() ;
    
    let svar_y = ( if (svar_x == 0) { 1f64 } else {( if (svar_x == 1) { svar_abs_2 } else {( if (svar_x == 2) { svar_abs_4 } else {( if (svar_x == 3) { svar_abs_6 } else {( if (svar_x == 4) { svar_abs_8 } else {( if (svar_x == 5) { svar_abs_10 } else {( if (svar_x == 6) { svar_abs_12 } else {0f64 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Dy1fuzzify {
      // |===| Inputs.
      svar_x: svar_x,
      svar_input: svar_input,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      svar_abs_12: svar_abs_12,
      svar_abs_11: svar_abs_11,
      svar_abs_10: svar_abs_10,
      svar_abs_9: svar_abs_9,
      svar_abs_8: svar_abs_8,
      svar_abs_7: svar_abs_7,
      svar_abs_6: svar_abs_6,
      svar_abs_5: svar_abs_5,
      svar_abs_4: svar_abs_4,
      svar_abs_3: svar_abs_3,
      svar_abs_2: svar_abs_2,
      svar_abs_1: svar_abs_1,
      svar_abs_0: svar_abs_0,
      
      // |===| Calls.
      dy1calc_5: dy1calc_5,
      dy1calc_4: dy1calc_4,
      dy1calc_3: dy1calc_3,
      dy1calc_2: dy1calc_2,
      dy1calc_1: dy1calc_1,
      dy1calc_0: dy1calc_0,
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    let svar_input = input.1 ;
    
    // |===| Computing next state.
    let svar_abs_9 = - (1f64 * - 3f64 / 10f64) ;
    let svar_abs_11 = - (1f64 * - 1f64) ;
    let svar_abs_7 = - (1f64 * - 1f64 / 10f64) ;
    let svar_abs_3 = - 1f64 / 10f64 ;
    let svar_abs_1 = - 3f64 / 10f64 ;
    let svar_abs_0 = - 1f64 ;
    let svar_abs_5 = 0f64 ;
    /*let dy1calc_5 = */ self.dy1calc_5.next( (
      svar_abs_0,
      svar_abs_1,
      svar_input,
    ) ) ;
    let (
      svar_abs_2,
    ) = self.dy1calc_5.output() ;
    /*let dy1calc_4 = */ self.dy1calc_4.next( (
      svar_abs_1,
      svar_abs_3,
      svar_input,
    ) ) ;
    let (
      svar_abs_4,
    ) = self.dy1calc_4.output() ;
    /*let dy1calc_3 = */ self.dy1calc_3.next( (
      svar_abs_3,
      svar_abs_5,
      svar_input,
    ) ) ;
    let (
      svar_abs_6,
    ) = self.dy1calc_3.output() ;
    /*let dy1calc_2 = */ self.dy1calc_2.next( (
      svar_abs_5,
      svar_abs_7,
      svar_input,
    ) ) ;
    let (
      svar_abs_8,
    ) = self.dy1calc_2.output() ;
    /*let dy1calc_1 = */ self.dy1calc_1.next( (
      svar_abs_7,
      svar_abs_9,
      svar_input,
    ) ) ;
    let (
      svar_abs_10,
    ) = self.dy1calc_1.output() ;
    /*let dy1calc_0 = */ self.dy1calc_0.next( (
      svar_abs_9,
      svar_abs_11,
      svar_input,
    ) ) ;
    let (
      svar_abs_12,
    ) = self.dy1calc_0.output() ;
    let svar_y = ( if (svar_x == 0) { 1f64 } else {( if (svar_x == 1) { svar_abs_2 } else {( if (svar_x == 2) { svar_abs_4 } else {( if (svar_x == 3) { svar_abs_6 } else {( if (svar_x == 4) { svar_abs_8 } else {( if (svar_x == 5) { svar_abs_10 } else {( if (svar_x == 6) { svar_abs_12 } else {0f64 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_x = svar_x ;
    self.svar_input = svar_input ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    self.svar_abs_12 = svar_abs_12 ;
    self.svar_abs_11 = svar_abs_11 ;
    self.svar_abs_10 = svar_abs_10 ;
    self.svar_abs_9 = svar_abs_9 ;
    self.svar_abs_8 = svar_abs_8 ;
    self.svar_abs_7 = svar_abs_7 ;
    self.svar_abs_6 = svar_abs_6 ;
    self.svar_abs_5 = svar_abs_5 ;
    self.svar_abs_4 = svar_abs_4 ;
    self.svar_abs_3 = svar_abs_3 ;
    self.svar_abs_2 = svar_abs_2 ;
    self.svar_abs_1 = svar_abs_1 ;
    self.svar_abs_0 = svar_abs_0 ;
    
    // |===| Calls.
    /*self.dy1calc_5 = dy1calc_5 ;
    self.dy1calc_4 = dy1calc_4 ;
    self.dy1calc_3 = dy1calc_3 ;
    self.dy1calc_2 = dy1calc_2 ;
    self.dy1calc_1 = dy1calc_1 ;
    self.dy1calc_0 = dy1calc_0 ;*/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `y2fuzzify`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `x` | Int |
/// | `input` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Real |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `y2calc` | [Y2calc](struct.Y2calc.html) | `abs_9`, `abs_11`, `input` | `abs_12` | [fuzzy.lus line 221](../src/lus/fuzzy.lus.html#221) |
/// | `y2calc` | [Y2calc](struct.Y2calc.html) | `abs_7`, `abs_9`, `input` | `abs_10` | [fuzzy.lus line 220](../src/lus/fuzzy.lus.html#220) |
/// | `y2calc` | [Y2calc](struct.Y2calc.html) | `abs_5`, `abs_7`, `input` | `abs_8` | [fuzzy.lus line 219](../src/lus/fuzzy.lus.html#219) |
/// | `y2calc` | [Y2calc](struct.Y2calc.html) | `abs_3`, `abs_5`, `input` | `abs_6` | [fuzzy.lus line 218](../src/lus/fuzzy.lus.html#218) |
/// | `y2calc` | [Y2calc](struct.Y2calc.html) | `abs_1`, `abs_3`, `input` | `abs_4` | [fuzzy.lus line 217](../src/lus/fuzzy.lus.html#217) |
/// | `y2calc` | [Y2calc](struct.Y2calc.html) | `abs_0`, `abs_1`, `input` | `abs_2` | [fuzzy.lus line 216](../src/lus/fuzzy.lus.html#216) |
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Y2fuzzify {
  /// Input: `y2fuzzify.usr.x`
  pub svar_x: Int,
  /// Input: `y2fuzzify.usr.input`
  pub svar_input: Real,

  /// Output: `y2fuzzify.usr.y`
  pub svar_y: Real,

  /// Local, call: `y2fuzzify.res.abs_12`
  pub svar_abs_12: Real,
  /// Local, invisible local: `y2fuzzify.res.abs_11`
  pub svar_abs_11: Real,
  /// Local, call: `y2fuzzify.res.abs_10`
  pub svar_abs_10: Real,
  /// Local, invisible local: `y2fuzzify.res.abs_9`
  pub svar_abs_9: Real,
  /// Local, call: `y2fuzzify.res.abs_8`
  pub svar_abs_8: Real,
  /// Local, invisible local: `y2fuzzify.res.abs_7`
  pub svar_abs_7: Real,
  /// Local, call: `y2fuzzify.res.abs_6`
  pub svar_abs_6: Real,
  /// Local, invisible local: `y2fuzzify.res.abs_5`
  pub svar_abs_5: Real,
  /// Local, call: `y2fuzzify.res.abs_4`
  pub svar_abs_4: Real,
  /// Local, invisible local: `y2fuzzify.res.abs_3`
  pub svar_abs_3: Real,
  /// Local, call: `y2fuzzify.res.abs_2`
  pub svar_abs_2: Real,
  /// Local, invisible local: `y2fuzzify.res.abs_1`
  pub svar_abs_1: Real,
  /// Local, invisible local: `y2fuzzify.res.abs_0`
  pub svar_abs_0: Real,

  /// Call to `y2calc` ([fuzzy.lus line 216](../src/lus/fuzzy.lus.html#216)).
  pub y2calc_5: Y2calc,
  /// Call to `y2calc` ([fuzzy.lus line 217](../src/lus/fuzzy.lus.html#217)).
  pub y2calc_4: Y2calc,
  /// Call to `y2calc` ([fuzzy.lus line 218](../src/lus/fuzzy.lus.html#218)).
  pub y2calc_3: Y2calc,
  /// Call to `y2calc` ([fuzzy.lus line 219](../src/lus/fuzzy.lus.html#219)).
  pub y2calc_2: Y2calc,
  /// Call to `y2calc` ([fuzzy.lus line 220](../src/lus/fuzzy.lus.html#220)).
  pub y2calc_1: Y2calc,
  /// Call to `y2calc` ([fuzzy.lus line 221](../src/lus/fuzzy.lus.html#221)).
  pub y2calc_0: Y2calc,
}

impl Sys for Y2fuzzify {
  type Input = (
    Int, // svar_x (y2fuzzify.usr.x)
    Real, // svar_input (y2fuzzify.usr.input)
  ) ;
  type Output = (
    Real, // svar_y (y2fuzzify.usr.y)
  ) ;
/*  fn arity() -> usize { 2 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::int(& vec[0]) ), 
              try!( parse::real(& vec[1]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    let svar_input = input.1 ;
    
    // |===| Computing initial state.
    let svar_abs_0 = - 17f64 / 20f64 ;
    let svar_abs_7 = - (1f64 * - 2f64 / 5f64) ;
    let svar_abs_3 = - 2f64 / 5f64 ;
    let svar_abs_1 = - 4f64 / 5f64 ;
    let svar_abs_11 = - (1f64 * - 17f64 / 20f64) ;
    let svar_abs_9 = - (1f64 * - 4f64 / 5f64) ;
    let svar_abs_5 = 0f64 ;
    let y2calc_5 = Y2calc::init( (
      svar_abs_0,
      svar_abs_1,
      svar_input,
    ) ) ;
    let (
      svar_abs_2,
    ) = y2calc_5.output() ;
    
    let y2calc_4 = Y2calc::init( (
      svar_abs_1,
      svar_abs_3,
      svar_input,
    ) ) ;
    let (
      svar_abs_4,
    ) = y2calc_4.output() ;
    
    let y2calc_3 = Y2calc::init( (
      svar_abs_3,
      svar_abs_5,
      svar_input,
    ) ) ;
    let (
      svar_abs_6,
    ) = y2calc_3.output() ;
    
    let y2calc_2 = Y2calc::init( (
      svar_abs_5,
      svar_abs_7,
      svar_input,
    ) ) ;
    let (
      svar_abs_8,
    ) = y2calc_2.output() ;
    
    let y2calc_1 = Y2calc::init( (
      svar_abs_7,
      svar_abs_9,
      svar_input,
    ) ) ;
    let (
      svar_abs_10,
    ) = y2calc_1.output() ;
    
    let y2calc_0 = Y2calc::init( (
      svar_abs_9,
      svar_abs_11,
      svar_input,
    ) ) ;
    let (
      svar_abs_12,
    ) = y2calc_0.output() ;
    
    let svar_y = ( if (svar_x == 0) { 0f64 } else {( if (svar_x == 1) { svar_abs_2 } else {( if (svar_x == 2) { svar_abs_4 } else {( if (svar_x == 3) { svar_abs_6 } else {( if (svar_x == 4) { svar_abs_8 } else {( if (svar_x == 5) { svar_abs_10 } else {( if (svar_x == 6) { svar_abs_12 } else {1f64 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Y2fuzzify {
      // |===| Inputs.
      svar_x: svar_x,
      svar_input: svar_input,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      svar_abs_12: svar_abs_12,
      svar_abs_11: svar_abs_11,
      svar_abs_10: svar_abs_10,
      svar_abs_9: svar_abs_9,
      svar_abs_8: svar_abs_8,
      svar_abs_7: svar_abs_7,
      svar_abs_6: svar_abs_6,
      svar_abs_5: svar_abs_5,
      svar_abs_4: svar_abs_4,
      svar_abs_3: svar_abs_3,
      svar_abs_2: svar_abs_2,
      svar_abs_1: svar_abs_1,
      svar_abs_0: svar_abs_0,
      
      // |===| Calls.
      y2calc_5: y2calc_5,
      y2calc_4: y2calc_4,
      y2calc_3: y2calc_3,
      y2calc_2: y2calc_2,
      y2calc_1: y2calc_1,
      y2calc_0: y2calc_0,
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    let svar_input = input.1 ;
    
    // |===| Computing next state.
    let svar_abs_0 = - 17f64 / 20f64 ;
    let svar_abs_7 = - (1f64 * - 2f64 / 5f64) ;
    let svar_abs_3 = - 2f64 / 5f64 ;
    let svar_abs_1 = - 4f64 / 5f64 ;
    let svar_abs_11 = - (1f64 * - 17f64 / 20f64) ;
    let svar_abs_9 = - (1f64 * - 4f64 / 5f64) ;
    let svar_abs_5 = 0f64 ;
    /*let y2calc_5 = */ self.y2calc_5.next( (
      svar_abs_0,
      svar_abs_1,
      svar_input,
    ) ) ;
    let (
      svar_abs_2,
    ) = self.y2calc_5.output() ;
    /*let y2calc_4 = */ self.y2calc_4.next( (
      svar_abs_1,
      svar_abs_3,
      svar_input,
    ) ) ;
    let (
      svar_abs_4,
    ) = self.y2calc_4.output() ;
    /*let y2calc_3 = */ self.y2calc_3.next( (
      svar_abs_3,
      svar_abs_5,
      svar_input,
    ) ) ;
    let (
      svar_abs_6,
    ) = self.y2calc_3.output() ;
    /*let y2calc_2 = */ self.y2calc_2.next( (
      svar_abs_5,
      svar_abs_7,
      svar_input,
    ) ) ;
    let (
      svar_abs_8,
    ) = self.y2calc_2.output() ;
    /*let y2calc_1 = */ self.y2calc_1.next( (
      svar_abs_7,
      svar_abs_9,
      svar_input,
    ) ) ;
    let (
      svar_abs_10,
    ) = self.y2calc_1.output() ;
    /*let y2calc_0 = */ self.y2calc_0.next( (
      svar_abs_9,
      svar_abs_11,
      svar_input,
    ) ) ;
    let (
      svar_abs_12,
    ) = self.y2calc_0.output() ;
    let svar_y = ( if (svar_x == 0) { 0f64 } else {( if (svar_x == 1) { svar_abs_2 } else {( if (svar_x == 2) { svar_abs_4 } else {( if (svar_x == 3) { svar_abs_6 } else {( if (svar_x == 4) { svar_abs_8 } else {( if (svar_x == 5) { svar_abs_10 } else {( if (svar_x == 6) { svar_abs_12 } else {1f64 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_x = svar_x ;
    self.svar_input = svar_input ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    self.svar_abs_12 = svar_abs_12 ;
    self.svar_abs_11 = svar_abs_11 ;
    self.svar_abs_10 = svar_abs_10 ;
    self.svar_abs_9 = svar_abs_9 ;
    self.svar_abs_8 = svar_abs_8 ;
    self.svar_abs_7 = svar_abs_7 ;
    self.svar_abs_6 = svar_abs_6 ;
    self.svar_abs_5 = svar_abs_5 ;
    self.svar_abs_4 = svar_abs_4 ;
    self.svar_abs_3 = svar_abs_3 ;
    self.svar_abs_2 = svar_abs_2 ;
    self.svar_abs_1 = svar_abs_1 ;
    self.svar_abs_0 = svar_abs_0 ;
    
    // |===| Calls.
    /*self.y2calc_5 = y2calc_5 ;
    self.y2calc_4 = y2calc_4 ;
    self.y2calc_3 = y2calc_3 ;
    self.y2calc_2 = y2calc_2 ;
    self.y2calc_1 = y2calc_1 ;
    self.y2calc_0 = y2calc_0 ;*/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `y1fuzzify`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `x` | Int |
/// | `input` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Real |
///
/// # Sub systems
///
/// | Lustre identifier | Struct | Inputs | Outputs | Position |
/// |:---:|:---:|:---:|:---:|:---:|
/// | `y1calc` | [Y1calc](struct.Y1calc.html) | `abs_9`, `abs_11`, `input` | `abs_12` | [fuzzy.lus line 204](../src/lus/fuzzy.lus.html#204) |
/// | `y1calc` | [Y1calc](struct.Y1calc.html) | `abs_7`, `abs_9`, `input` | `abs_10` | [fuzzy.lus line 203](../src/lus/fuzzy.lus.html#203) |
/// | `y1calc` | [Y1calc](struct.Y1calc.html) | `abs_5`, `abs_7`, `input` | `abs_8` | [fuzzy.lus line 202](../src/lus/fuzzy.lus.html#202) |
/// | `y1calc` | [Y1calc](struct.Y1calc.html) | `abs_3`, `abs_5`, `input` | `abs_6` | [fuzzy.lus line 201](../src/lus/fuzzy.lus.html#201) |
/// | `y1calc` | [Y1calc](struct.Y1calc.html) | `abs_1`, `abs_3`, `input` | `abs_4` | [fuzzy.lus line 200](../src/lus/fuzzy.lus.html#200) |
/// | `y1calc` | [Y1calc](struct.Y1calc.html) | `abs_0`, `abs_1`, `input` | `abs_2` | [fuzzy.lus line 199](../src/lus/fuzzy.lus.html#199) |
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Y1fuzzify {
  /// Input: `y1fuzzify.usr.x`
  pub svar_x: Int,
  /// Input: `y1fuzzify.usr.input`
  pub svar_input: Real,

  /// Output: `y1fuzzify.usr.y`
  pub svar_y: Real,

  /// Local, call: `y1fuzzify.res.abs_12`
  pub svar_abs_12: Real,
  /// Local, invisible local: `y1fuzzify.res.abs_11`
  pub svar_abs_11: Real,
  /// Local, call: `y1fuzzify.res.abs_10`
  pub svar_abs_10: Real,
  /// Local, invisible local: `y1fuzzify.res.abs_9`
  pub svar_abs_9: Real,
  /// Local, call: `y1fuzzify.res.abs_8`
  pub svar_abs_8: Real,
  /// Local, invisible local: `y1fuzzify.res.abs_7`
  pub svar_abs_7: Real,
  /// Local, call: `y1fuzzify.res.abs_6`
  pub svar_abs_6: Real,
  /// Local, invisible local: `y1fuzzify.res.abs_5`
  pub svar_abs_5: Real,
  /// Local, call: `y1fuzzify.res.abs_4`
  pub svar_abs_4: Real,
  /// Local, invisible local: `y1fuzzify.res.abs_3`
  pub svar_abs_3: Real,
  /// Local, call: `y1fuzzify.res.abs_2`
  pub svar_abs_2: Real,
  /// Local, invisible local: `y1fuzzify.res.abs_1`
  pub svar_abs_1: Real,
  /// Local, invisible local: `y1fuzzify.res.abs_0`
  pub svar_abs_0: Real,

  /// Call to `y1calc` ([fuzzy.lus line 199](../src/lus/fuzzy.lus.html#199)).
  pub y1calc_5: Y1calc,
  /// Call to `y1calc` ([fuzzy.lus line 200](../src/lus/fuzzy.lus.html#200)).
  pub y1calc_4: Y1calc,
  /// Call to `y1calc` ([fuzzy.lus line 201](../src/lus/fuzzy.lus.html#201)).
  pub y1calc_3: Y1calc,
  /// Call to `y1calc` ([fuzzy.lus line 202](../src/lus/fuzzy.lus.html#202)).
  pub y1calc_2: Y1calc,
  /// Call to `y1calc` ([fuzzy.lus line 203](../src/lus/fuzzy.lus.html#203)).
  pub y1calc_1: Y1calc,
  /// Call to `y1calc` ([fuzzy.lus line 204](../src/lus/fuzzy.lus.html#204)).
  pub y1calc_0: Y1calc,
}

impl Sys for Y1fuzzify {
  type Input = (
    Int, // svar_x (y1fuzzify.usr.x)
    Real, // svar_input (y1fuzzify.usr.input)
  ) ;
  type Output = (
    Real, // svar_y (y1fuzzify.usr.y)
  ) ;
/*  fn arity() -> usize { 2 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::int(& vec[0]) ), 
              try!( parse::real(& vec[1]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    let svar_input = input.1 ;
    
    // |===| Computing initial state.
    let svar_abs_0 = - 17f64 / 20f64 ;
    let svar_abs_7 = - (1f64 * - 2f64 / 5f64) ;
    let svar_abs_3 = - 2f64 / 5f64 ;
    let svar_abs_1 = - 4f64 / 5f64 ;
    let svar_abs_11 = - (1f64 * - 17f64 / 20f64) ;
    let svar_abs_9 = - (1f64 * - 4f64 / 5f64) ;
    let svar_abs_5 = 0f64 ;
    let y1calc_5 = Y1calc::init( (
      svar_abs_0,
      svar_abs_1,
      svar_input,
    ) ) ;
    let (
      svar_abs_2,
    ) = y1calc_5.output() ;
    
    let y1calc_4 = Y1calc::init( (
      svar_abs_1,
      svar_abs_3,
      svar_input,
    ) ) ;
    let (
      svar_abs_4,
    ) = y1calc_4.output() ;
    
    let y1calc_3 = Y1calc::init( (
      svar_abs_3,
      svar_abs_5,
      svar_input,
    ) ) ;
    let (
      svar_abs_6,
    ) = y1calc_3.output() ;
    
    let y1calc_2 = Y1calc::init( (
      svar_abs_5,
      svar_abs_7,
      svar_input,
    ) ) ;
    let (
      svar_abs_8,
    ) = y1calc_2.output() ;
    
    let y1calc_1 = Y1calc::init( (
      svar_abs_7,
      svar_abs_9,
      svar_input,
    ) ) ;
    let (
      svar_abs_10,
    ) = y1calc_1.output() ;
    
    let y1calc_0 = Y1calc::init( (
      svar_abs_9,
      svar_abs_11,
      svar_input,
    ) ) ;
    let (
      svar_abs_12,
    ) = y1calc_0.output() ;
    
    let svar_y = ( if (svar_x == 0) { 1f64 } else {( if (svar_x == 1) { svar_abs_2 } else {( if (svar_x == 2) { svar_abs_4 } else {( if (svar_x == 3) { svar_abs_6 } else {( if (svar_x == 4) { svar_abs_8 } else {( if (svar_x == 5) { svar_abs_10 } else {( if (svar_x == 6) { svar_abs_12 } else {0f64 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Y1fuzzify {
      // |===| Inputs.
      svar_x: svar_x,
      svar_input: svar_input,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      svar_abs_12: svar_abs_12,
      svar_abs_11: svar_abs_11,
      svar_abs_10: svar_abs_10,
      svar_abs_9: svar_abs_9,
      svar_abs_8: svar_abs_8,
      svar_abs_7: svar_abs_7,
      svar_abs_6: svar_abs_6,
      svar_abs_5: svar_abs_5,
      svar_abs_4: svar_abs_4,
      svar_abs_3: svar_abs_3,
      svar_abs_2: svar_abs_2,
      svar_abs_1: svar_abs_1,
      svar_abs_0: svar_abs_0,
      
      // |===| Calls.
      y1calc_5: y1calc_5,
      y1calc_4: y1calc_4,
      y1calc_3: y1calc_3,
      y1calc_2: y1calc_2,
      y1calc_1: y1calc_1,
      y1calc_0: y1calc_0,
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    let svar_input = input.1 ;
    
    // |===| Computing next state.
    let svar_abs_0 = - 17f64 / 20f64 ;
    let svar_abs_7 = - (1f64 * - 2f64 / 5f64) ;
    let svar_abs_3 = - 2f64 / 5f64 ;
    let svar_abs_1 = - 4f64 / 5f64 ;
    let svar_abs_11 = - (1f64 * - 17f64 / 20f64) ;
    let svar_abs_9 = - (1f64 * - 4f64 / 5f64) ;
    let svar_abs_5 = 0f64 ;
    /*let y1calc_5 = */ self.y1calc_5.next( (
      svar_abs_0,
      svar_abs_1,
      svar_input,
    ) ) ;
    let (
      svar_abs_2,
    ) = self.y1calc_5.output() ;
    /*let y1calc_4 = */ self.y1calc_4.next( (
      svar_abs_1,
      svar_abs_3,
      svar_input,
    ) ) ;
    let (
      svar_abs_4,
    ) = self.y1calc_4.output() ;
    /*let y1calc_3 = */ self.y1calc_3.next( (
      svar_abs_3,
      svar_abs_5,
      svar_input,
    ) ) ;
    let (
      svar_abs_6,
    ) = self.y1calc_3.output() ;
    /*let y1calc_2 = */ self.y1calc_2.next( (
      svar_abs_5,
      svar_abs_7,
      svar_input,
    ) ) ;
    let (
      svar_abs_8,
    ) = self.y1calc_2.output() ;
    /*let y1calc_1 = */ self.y1calc_1.next( (
      svar_abs_7,
      svar_abs_9,
      svar_input,
    ) ) ;
    let (
      svar_abs_10,
    ) = self.y1calc_1.output() ;
    /*let y1calc_0 = */ self.y1calc_0.next( (
      svar_abs_9,
      svar_abs_11,
      svar_input,
    ) ) ;
    let (
      svar_abs_12,
    ) = self.y1calc_0.output() ;
    let svar_y = ( if (svar_x == 0) { 1f64 } else {( if (svar_x == 1) { svar_abs_2 } else {( if (svar_x == 2) { svar_abs_4 } else {( if (svar_x == 3) { svar_abs_6 } else {( if (svar_x == 4) { svar_abs_8 } else {( if (svar_x == 5) { svar_abs_10 } else {( if (svar_x == 6) { svar_abs_12 } else {0f64 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_x = svar_x ;
    self.svar_input = svar_input ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    self.svar_abs_12 = svar_abs_12 ;
    self.svar_abs_11 = svar_abs_11 ;
    self.svar_abs_10 = svar_abs_10 ;
    self.svar_abs_9 = svar_abs_9 ;
    self.svar_abs_8 = svar_abs_8 ;
    self.svar_abs_7 = svar_abs_7 ;
    self.svar_abs_6 = svar_abs_6 ;
    self.svar_abs_5 = svar_abs_5 ;
    self.svar_abs_4 = svar_abs_4 ;
    self.svar_abs_3 = svar_abs_3 ;
    self.svar_abs_2 = svar_abs_2 ;
    self.svar_abs_1 = svar_abs_1 ;
    self.svar_abs_0 = svar_abs_0 ;
    
    // |===| Calls.
    /*self.y1calc_5 = y1calc_5 ;
    self.y1calc_4 = y1calc_4 ;
    self.y1calc_3 = y1calc_3 ;
    self.y1calc_2 = y1calc_2 ;
    self.y1calc_1 = y1calc_1 ;
    self.y1calc_0 = y1calc_0 ;*/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `rule_base`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `x` | Int |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Real |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Rule_base {
  /// Input: `rule_base.usr.x`
  pub svar_x: Int,

  /// Output: `rule_base.usr.y`
  pub svar_y: Real,


}

impl Sys for Rule_base {
  type Input = (
    Int, // svar_x (rule_base.usr.x)
  ) ;
  type Output = (
    Real, // svar_y (rule_base.usr.y)
  ) ;
/*  fn arity() -> usize { 1 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::int(& vec[0]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    
    // |===| Computing initial state.
    let svar_y = ( if (svar_x == 1) { - 1f64 } else {( if (svar_x == 2) { - 1f64 } else {( if (svar_x == 3) { - 1f64 } else {( if (svar_x == 4) { - 1f64 } else {( if (svar_x == 5) { - 7f64 / 10f64 } else {( if (svar_x == 6) { - 3f64 / 10f64 } else {( if (svar_x == 7) { 0f64 } else {( if (svar_x == 8) { - 1f64 } else {( if (svar_x == 9) { - 1f64 } else {( if (svar_x == 10) { - 1f64 } else {( if (svar_x == 11) { - 7f64 / 10f64 } else {( if (svar_x == 12) { - 3f64 / 10f64 } else {( if (svar_x == 13) { 0f64 } else {( if (svar_x == 14) { 3f64 / 10f64 } else {( if (svar_x == 15) { - 1f64 } else {( if (svar_x == 16) { - 1f64 } else {( if (svar_x == 17) { - 7f64 / 10f64 } else {( if (svar_x == 18) { - 3f64 / 10f64 } else {( if (svar_x == 19) { 0f64 } else {( if (svar_x == 20) { 3f64 / 10f64 } else {( if (svar_x == 21) { 7f64 / 10f64 } else {( if (svar_x == 22) { - 1f64 } else {( if (svar_x == 23) { - 7f64 / 10f64 } else {( if (svar_x == 24) { - 3f64 / 10f64 } else {( if (svar_x == 25) { 0f64 } else {( if (svar_x == 26) { 3f64 / 10f64 } else {( if (svar_x == 27) { 7f64 / 10f64 } else {( if (svar_x == 28) { 1f64 } else {( if (svar_x == 29) { - 7f64 / 10f64 } else {( if (svar_x == 30) { - 3f64 / 10f64 } else {( if (svar_x == 31) { 0f64 } else {( if (svar_x == 32) { 3f64 / 10f64 } else {( if (svar_x == 33) { 7f64 / 10f64 } else {( if (svar_x == 34) { 1f64 } else {( if (svar_x == 35) { 1f64 } else {( if (svar_x == 36) { - 3f64 / 10f64 } else {( if (svar_x == 37) { 0f64 } else {( if (svar_x == 38) { 3f64 / 10f64 } else {( if (svar_x == 39) { 7f64 / 10f64 } else {( if (svar_x == 40) { 1f64 } else {( if (svar_x == 41) { 1f64 } else {( if (svar_x == 42) { 1f64 } else {( if (svar_x == 43) { 0f64 } else {( if (svar_x == 44) { 3f64 / 10f64 } else {( if (svar_x == 45) { 7f64 / 10f64 } else {1f64 } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Rule_base {
      // |===| Inputs.
      svar_x: svar_x,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    
    // |===| Computing next state.
    let svar_y = ( if (svar_x == 1) { - 1f64 } else {( if (svar_x == 2) { - 1f64 } else {( if (svar_x == 3) { - 1f64 } else {( if (svar_x == 4) { - 1f64 } else {( if (svar_x == 5) { - 7f64 / 10f64 } else {( if (svar_x == 6) { - 3f64 / 10f64 } else {( if (svar_x == 7) { 0f64 } else {( if (svar_x == 8) { - 1f64 } else {( if (svar_x == 9) { - 1f64 } else {( if (svar_x == 10) { - 1f64 } else {( if (svar_x == 11) { - 7f64 / 10f64 } else {( if (svar_x == 12) { - 3f64 / 10f64 } else {( if (svar_x == 13) { 0f64 } else {( if (svar_x == 14) { 3f64 / 10f64 } else {( if (svar_x == 15) { - 1f64 } else {( if (svar_x == 16) { - 1f64 } else {( if (svar_x == 17) { - 7f64 / 10f64 } else {( if (svar_x == 18) { - 3f64 / 10f64 } else {( if (svar_x == 19) { 0f64 } else {( if (svar_x == 20) { 3f64 / 10f64 } else {( if (svar_x == 21) { 7f64 / 10f64 } else {( if (svar_x == 22) { - 1f64 } else {( if (svar_x == 23) { - 7f64 / 10f64 } else {( if (svar_x == 24) { - 3f64 / 10f64 } else {( if (svar_x == 25) { 0f64 } else {( if (svar_x == 26) { 3f64 / 10f64 } else {( if (svar_x == 27) { 7f64 / 10f64 } else {( if (svar_x == 28) { 1f64 } else {( if (svar_x == 29) { - 7f64 / 10f64 } else {( if (svar_x == 30) { - 3f64 / 10f64 } else {( if (svar_x == 31) { 0f64 } else {( if (svar_x == 32) { 3f64 / 10f64 } else {( if (svar_x == 33) { 7f64 / 10f64 } else {( if (svar_x == 34) { 1f64 } else {( if (svar_x == 35) { 1f64 } else {( if (svar_x == 36) { - 3f64 / 10f64 } else {( if (svar_x == 37) { 0f64 } else {( if (svar_x == 38) { 3f64 / 10f64 } else {( if (svar_x == 39) { 7f64 / 10f64 } else {( if (svar_x == 40) { 1f64 } else {( if (svar_x == 41) { 1f64 } else {( if (svar_x == 42) { 1f64 } else {( if (svar_x == 43) { 0f64 } else {( if (svar_x == 44) { 3f64 / 10f64 } else {( if (svar_x == 45) { 7f64 / 10f64 } else {1f64 } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_x = svar_x ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    /**/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `findlocation_d`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `x` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Int |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Findlocation_d {
  /// Input: `findlocation_d.usr.x`
  pub svar_x: Real,

  /// Output: `findlocation_d.usr.y`
  pub svar_y: Int,


}

impl Sys for Findlocation_d {
  type Input = (
    Real, // svar_x (findlocation_d.usr.x)
  ) ;
  type Output = (
    Int, // svar_y (findlocation_d.usr.y)
  ) ;
/*  fn arity() -> usize { 1 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::real(& vec[0]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    
    // |===| Computing initial state.
    let svar_y = ( if (svar_x < - 1f64) { 0 } else {( if ((svar_x >= - 1f64) & (svar_x <= - 3f64 / 10f64)) { 1 } else {( if ((svar_x >= - 3f64 / 10f64) & (svar_x <= - 1f64 / 10f64)) { 2 } else {( if ((svar_x >= - 1f64 / 10f64) & (svar_x <= 0f64)) { 3 } else {( if ((svar_x >= 0f64) & (svar_x <= - (1f64 * - 1f64 / 10f64))) { 4 } else {( if ((svar_x >= - (1f64 * - 1f64 / 10f64)) & (svar_x <= - (1f64 * - 3f64 / 10f64))) { 5 } else {( if ((svar_x >= - (1f64 * - 3f64 / 10f64)) & (svar_x <= - (1f64 * - 1f64))) { 6 } else {7 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Findlocation_d {
      // |===| Inputs.
      svar_x: svar_x,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    
    // |===| Computing next state.
    let svar_y = ( if (svar_x < - 1f64) { 0 } else {( if ((svar_x >= - 1f64) & (svar_x <= - 3f64 / 10f64)) { 1 } else {( if ((svar_x >= - 3f64 / 10f64) & (svar_x <= - 1f64 / 10f64)) { 2 } else {( if ((svar_x >= - 1f64 / 10f64) & (svar_x <= 0f64)) { 3 } else {( if ((svar_x >= 0f64) & (svar_x <= - (1f64 * - 1f64 / 10f64))) { 4 } else {( if ((svar_x >= - (1f64 * - 1f64 / 10f64)) & (svar_x <= - (1f64 * - 3f64 / 10f64))) { 5 } else {( if ((svar_x >= - (1f64 * - 3f64 / 10f64)) & (svar_x <= - (1f64 * - 1f64))) { 6 } else {7 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_x = svar_x ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    /**/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `findlocation_p`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `x` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Int |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Findlocation_p {
  /// Input: `findlocation_p.usr.x`
  pub svar_x: Real,

  /// Output: `findlocation_p.usr.y`
  pub svar_y: Int,


}

impl Sys for Findlocation_p {
  type Input = (
    Real, // svar_x (findlocation_p.usr.x)
  ) ;
  type Output = (
    Int, // svar_y (findlocation_p.usr.y)
  ) ;
/*  fn arity() -> usize { 1 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::real(& vec[0]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    
    // |===| Computing initial state.
    let svar_y = ( if (svar_x < - 17f64 / 20f64) { 0 } else {( if ((svar_x >= - 17f64 / 20f64) & (svar_x <= - 4f64 / 5f64)) { 1 } else {( if ((svar_x >= - 4f64 / 5f64) & (svar_x <= - 2f64 / 5f64)) { 2 } else {( if ((svar_x >= - 2f64 / 5f64) & (svar_x <= 0f64)) { 3 } else {( if ((svar_x >= 0f64) & (svar_x <= - (1f64 * - 2f64 / 5f64))) { 4 } else {( if ((svar_x >= - (1f64 * - 2f64 / 5f64)) & (svar_x <= - (1f64 * - 4f64 / 5f64))) { 5 } else {( if ((svar_x >= - (1f64 * - 4f64 / 5f64)) & (svar_x <= - (1f64 * - 17f64 / 20f64))) { 6 } else {7 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Findlocation_p {
      // |===| Inputs.
      svar_x: svar_x,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_x = input.0 ;
    
    // |===| Computing next state.
    let svar_y = ( if (svar_x < - 17f64 / 20f64) { 0 } else {( if ((svar_x >= - 17f64 / 20f64) & (svar_x <= - 4f64 / 5f64)) { 1 } else {( if ((svar_x >= - 4f64 / 5f64) & (svar_x <= - 2f64 / 5f64)) { 2 } else {( if ((svar_x >= - 2f64 / 5f64) & (svar_x <= 0f64)) { 3 } else {( if ((svar_x >= 0f64) & (svar_x <= - (1f64 * - 2f64 / 5f64))) { 4 } else {( if ((svar_x >= - (1f64 * - 2f64 / 5f64)) & (svar_x <= - (1f64 * - 4f64 / 5f64))) { 5 } else {( if ((svar_x >= - (1f64 * - 4f64 / 5f64)) & (svar_x <= - (1f64 * - 17f64 / 20f64))) { 6 } else {7 } ) } ) } ) } ) } ) } ) } ) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_x = svar_x ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    /**/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `dy2calc`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `low` | Real |
/// | `high` | Real |
/// | `x` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Real |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Dy2calc {
  /// Input: `dy2calc.usr.low`
  pub svar_low: Real,
  /// Input: `dy2calc.usr.high`
  pub svar_high: Real,
  /// Input: `dy2calc.usr.x`
  pub svar_x: Real,

  /// Output: `dy2calc.usr.y`
  pub svar_y: Real,


}

impl Sys for Dy2calc {
  type Input = (
    Real, // svar_low (dy2calc.usr.low)
    Real, // svar_high (dy2calc.usr.high)
    Real, // svar_x (dy2calc.usr.x)
  ) ;
  type Output = (
    Real, // svar_y (dy2calc.usr.y)
  ) ;
/*  fn arity() -> usize { 3 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::real(& vec[0]) ), 
              try!( parse::real(& vec[1]) ), 
              try!( parse::real(& vec[2]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_low = input.0 ;
    let svar_high = input.1 ;
    let svar_x = input.2 ;
    
    // |===| Computing initial state.
    let svar_y = ((svar_x - svar_low) / (svar_high - svar_low)) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Dy2calc {
      // |===| Inputs.
      svar_low: svar_low,
      svar_high: svar_high,
      svar_x: svar_x,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_low = input.0 ;
    let svar_high = input.1 ;
    let svar_x = input.2 ;
    
    // |===| Computing next state.
    let svar_y = ((svar_x - svar_low) / (svar_high - svar_low)) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_low = svar_low ;
    self.svar_high = svar_high ;
    self.svar_x = svar_x ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    /**/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `dy1calc`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `low` | Real |
/// | `high` | Real |
/// | `x` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Real |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Dy1calc {
  /// Input: `dy1calc.usr.low`
  pub svar_low: Real,
  /// Input: `dy1calc.usr.high`
  pub svar_high: Real,
  /// Input: `dy1calc.usr.x`
  pub svar_x: Real,

  /// Output: `dy1calc.usr.y`
  pub svar_y: Real,


}

impl Sys for Dy1calc {
  type Input = (
    Real, // svar_low (dy1calc.usr.low)
    Real, // svar_high (dy1calc.usr.high)
    Real, // svar_x (dy1calc.usr.x)
  ) ;
  type Output = (
    Real, // svar_y (dy1calc.usr.y)
  ) ;
/*  fn arity() -> usize { 3 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::real(& vec[0]) ), 
              try!( parse::real(& vec[1]) ), 
              try!( parse::real(& vec[2]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_low = input.0 ;
    let svar_high = input.1 ;
    let svar_x = input.2 ;
    
    // |===| Computing initial state.
    let svar_y = ((svar_high - svar_x) / (svar_high - svar_low)) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Dy1calc {
      // |===| Inputs.
      svar_low: svar_low,
      svar_high: svar_high,
      svar_x: svar_x,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_low = input.0 ;
    let svar_high = input.1 ;
    let svar_x = input.2 ;
    
    // |===| Computing next state.
    let svar_y = ((svar_high - svar_x) / (svar_high - svar_low)) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_low = svar_low ;
    self.svar_high = svar_high ;
    self.svar_x = svar_x ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    /**/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `y2calc`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `low` | Real |
/// | `high` | Real |
/// | `x` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Real |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Y2calc {
  /// Input: `y2calc.usr.low`
  pub svar_low: Real,
  /// Input: `y2calc.usr.high`
  pub svar_high: Real,
  /// Input: `y2calc.usr.x`
  pub svar_x: Real,

  /// Output: `y2calc.usr.y`
  pub svar_y: Real,


}

impl Sys for Y2calc {
  type Input = (
    Real, // svar_low (y2calc.usr.low)
    Real, // svar_high (y2calc.usr.high)
    Real, // svar_x (y2calc.usr.x)
  ) ;
  type Output = (
    Real, // svar_y (y2calc.usr.y)
  ) ;
/*  fn arity() -> usize { 3 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::real(& vec[0]) ), 
              try!( parse::real(& vec[1]) ), 
              try!( parse::real(& vec[2]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_low = input.0 ;
    let svar_high = input.1 ;
    let svar_x = input.2 ;
    
    // |===| Computing initial state.
    let svar_y = ((svar_x - svar_low) / (svar_high - svar_low)) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Y2calc {
      // |===| Inputs.
      svar_low: svar_low,
      svar_high: svar_high,
      svar_x: svar_x,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_low = input.0 ;
    let svar_high = input.1 ;
    let svar_x = input.2 ;
    
    // |===| Computing next state.
    let svar_y = ((svar_x - svar_low) / (svar_high - svar_low)) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_low = svar_low ;
    self.svar_high = svar_high ;
    self.svar_x = svar_x ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    /**/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}

/// Stores the state for sub-node `y1calc`.
///
/// # Inputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `low` | Real |
/// | `high` | Real |
/// | `x` | Real |
///
/// # Outputs
///
/// | Lustre identifier | Type |
/// |:---:|:---|
/// | `y` | Real |
///
/// # Sub systems
///
/// No subsystems for this system.
///
/// # Assertions
///
/// /// No assertions for this system.
///
/// # Assumptions
///
/// No assumptions for this system.
///
#[repr(C)]
  pub struct Y1calc {
  /// Input: `y1calc.usr.low`
  pub svar_low: Real,
  /// Input: `y1calc.usr.high`
  pub svar_high: Real,
  /// Input: `y1calc.usr.x`
  pub svar_x: Real,

  /// Output: `y1calc.usr.y`
  pub svar_y: Real,


}

impl Sys for Y1calc {
  type Input = (
    Real, // svar_low (y1calc.usr.low)
    Real, // svar_high (y1calc.usr.high)
    Real, // svar_x (y1calc.usr.x)
  ) ;
  type Output = (
    Real, // svar_y (y1calc.usr.y)
  ) ;
/*  fn arity() -> usize { 3 }
*//*  fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {
        match vec.len() {
          n if n == Self::arity() => {
            (
              try!( parse::real(& vec[0]) ), 
              try!( parse::real(& vec[1]) ), 
              try!( parse::real(& vec[2]) ),
            ) 
          },
          n => Err(
            format!(
              "arity mismatch, expected {} but got {}: {:?}",
              Self::arity(), n, vec
            )
            
          ),
        }
      }

*/   fn init(input: Self::Input) -> Self {
    // |===| Retrieving inputs.
    let svar_low = input.0 ;
    let svar_high = input.1 ;
    let svar_x = input.2 ;
    
    // |===| Computing initial state.
    let svar_y = ((svar_high - svar_x) / (svar_high - svar_low)) ;
    
    // |===| Checking assertions.
    
    
    
    
    // |===| Returning initial state.
    Y1calc {
      // |===| Inputs.
      svar_low: svar_low,
      svar_high: svar_high,
      svar_x: svar_x,
      
      // |===| Outputs.
      svar_y: svar_y,
      
      // |===| Locals.
      
      
      // |===| Calls.
      
    } 
  }

  fn next(&mut self, input: Self::Input) {
    // |===| Retrieving inputs.
    let svar_low = input.0 ;
    let svar_high = input.1 ;
    let svar_x = input.2 ;
    
    // |===| Computing next state.
    let svar_y = ((svar_high - svar_x) / (svar_high - svar_low)) ;
    
    // |===| Checking assertions.
    
    
    // |===| Checking assumptions.
    
    
    // |===| Updating next state.
    // |===| Inputs.
    self.svar_low = svar_low ;
    self.svar_high = svar_high ;
    self.svar_x = svar_x ;
    
    // |===| Outputs.
    self.svar_y = svar_y ;
    
    // |===| Locals.
    
    
    // |===| Calls.
    /**/ 
    
    // |===| Return new state.
    /*Ok( self )*/
  }

  fn output(& self) -> Self::Output {(
    self.svar_y,
  )}
/*  fn output_str(& self) -> String {
      format!(
        "{}",
        self.svar_y
      )
    }*/
}



/// Types and structures for systems.
pub mod helpers {
 /* use std::io::{ Stdin, stdin } ;
  use std::process::exit ;

  /// Prints usage.
  pub fn help() {
    println!("") ;
    println!("\
Options:
  -h, --help
    prints this message
  --y1calc
    inputs:  Real (low)
             Real (high)
             Real (x)
    outputs: Real (y)
  --y2calc
    inputs:  Real (low)
             Real (high)
             Real (x)
    outputs: Real (y)
  --dy1calc
    inputs:  Real (low)
             Real (high)
             Real (x)
    outputs: Real (y)
  --dy2calc
    inputs:  Real (low)
             Real (high)
             Real (x)
    outputs: Real (y)
  --findlocation_p
    inputs:  Real (x)
    outputs: Int (y)
  --findlocation_d
    inputs:  Real (x)
    outputs: Int (y)
  --rule_base
    inputs:  Int (x)
    outputs: Real (y)
  --y1fuzzify
    inputs:  Int (x)
             Real (input)
    outputs: Real (y)
  --y2fuzzify
    inputs:  Int (x)
             Real (input)
    outputs: Real (y)
  --dy1fuzzify
    inputs:  Int (x)
             Real (input)
    outputs: Real (y)
  --dy2fuzzify
    inputs:  Int (x)
             Real (input)
    outputs: Real (y)
  --kmlogic
    inputs:  Real (pinput)
             Real (dinput)
    outputs: Real (g)
  --compute
    inputs:  Real (Input)
             Real (Now)
             Real (Kp)
             Real (Kd)
             Real (Setpoint)
             Real (SampleTime)
    outputs: Real (Output)
Usage:
  Inputs (outputs) are read (printed) as comma-separated values on a single
  line.
  The read-eval-print loop runs forever, write \"exit\" or \"quit\"
  to exit it cleanly.
Default system: \"compute\".\
    ") ;
    println!("")
  }

  /// Prints usage, an error, and exits with status `2`.
  pub fn error<T: ::std::fmt::Display>(e: T) {
    help() ;
    println!("Error: {}", e) ;
    println!("") ;
    exit(2)
  }

  /// Handles CLA.
  pub fn clap_and_run() {
    use std::env::args ;
    let mut args = args() ;
    // Skipping first argument (name of binary).
    match args.next() {
      Some(_) => (),
      None => unreachable!(),
    } ;
    if let Some(arg) = args.next() {
      match & arg as & str {
        "-h" | "--help" => {
          help() ;
          exit(0)
        },
        "--y1calc" => super::Y1calc::run(),
        "--y2calc" => super::Y2calc::run(),
        "--dy1calc" => super::Dy1calc::run(),
        "--dy2calc" => super::Dy2calc::run(),
        "--findlocation_p" => super::Findlocation_p::run(),
        "--findlocation_d" => super::Findlocation_d::run(),
        "--rule_base" => super::Rule_base::run(),
        "--y1fuzzify" => super::Y1fuzzify::run(),
        "--y2fuzzify" => super::Y2fuzzify::run(),
        "--dy1fuzzify" => super::Dy1fuzzify::run(),
        "--dy2fuzzify" => super::Dy2fuzzify::run(),
        "--kmlogic" => super::Kmlogic::run(),
        "--compute" => super::Compute::run(),
        arg => error(
          format!("unexpected argument \"{}\".", arg)
        ),
      }
    } ;
    // If no argument given, run top system.
    super::Compute::run()
  }*/

  /// Alias for `i64`.
  pub type Int = i64 ;
  /// Alias for `f64`.
  pub type Real = f64 ;
  /// Alias for `bool`.
  pub type Bool = bool ;

  /// Stores an `Stdin` and a buffer to read lines.
   /* pub struct InputReader {
    /// Standard input.
    stdin: Stdin,
    /// String buffer.
    buff: String,
  }
  impl InputReader {
    /// Creates an input reader.
    pub fn mk() -> Self {
      InputReader {
        stdin: stdin(),
        buff: String::with_capacity(100),
      }
    }
    /// Reads comma separated inputs from standard input.
    pub fn read_inputs(& mut self) -> Result<Vec<String>, String> {
      self.buff.clear() ;
      match self.stdin.read_line(& mut self.buff) {
        Ok(_) => (),
        Err(e) => return Err(
          format!("could not read line from stdin: {}", e)
        ),
      } ;
      let chars = self.buff.trim_left().chars() ;
      let mut buff = String::new() ;
      let mut vec = vec![] ;
      for c in chars {
        match c {
          ' ' | '\t' => (),
          ',' | '\n' => {
            vec.push(buff.clone()) ;
            buff.clear()
          },
          _ => buff.push(c),
        }
      } ;
      if vec.len() > 1 {
        match vec[0].trim() {
          "exit" | "quit" => exit(0),
          _ => ()
        }
      } ;
      Ok(vec)
    }
  } */

  /// Trait all systems must implement.
  pub trait Sys: Sized {
    /// Type of inputs.
    type Input ;
    /// Type of outputs.
    type Output ;
    /// Number of inputs expected.
    /*fn arity() -> usize ;
    /// Parses a vector of inputs.
    fn input_of(Vec<String>) -> Result<Self::Input, String> ;*/
    /// Initial state of the system.
    fn init(input: Self::Input) -> Self ;
    /// Computes the next step.
    fn next(&mut self, input: Self::Input) ;
    /// Reads inputs from standard input, computes initial state, prints output.
    /* fn read_init(reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let init = try!( Self::init(inputs) ) ;
          println!("{}", init.output_str()) ;
          Ok(init)
        },
        Err(s) => Err(s),
      }
    } */
    fn read_init(input: Self::Input) -> Self{
      Self::init(input)
    }

    /// Reads inputs from standard input, computes next step, prints output.
    /* fn read_next(self, reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let next = try!( self.next(inputs) ) ;
          println!("{}", next.output_str()) ;
          Ok(next)
        },
        Err(s) => Err(s),
      }
    } */
    fn read_next(&mut self, input: Self::Input){
      self.next(input);
    }

    /// Output of the system.
    fn output(& self) -> Self::Output ;
    // String representation of the output.
    // fn output_str(& self) -> String ;
    // Runs a never-ending, read-eval-print loop on the system.
    /* fn run() -> ! {
      let mut reader = InputReader::mk() ;
      let mut state = match Self::read_init(& mut reader) {
        Ok(init) => init,
        Err(e) => {
          println!("(Error: {})", e) ;
          exit(2)
        }
      } ;
      loop {
        match state.read_next(& mut reader) {
          Ok(next) => state = next,
          Err(e) => {
            println!("(Error: {})", e) ;
            exit(2)
          }
        }
      }
    } */
  }
}

// Parsing functions.
/* pub mod parse {
  use helpers::{ Int, Real, Bool } ;
  use std::fmt::Display ;
  use std::str::FromStr ;
  /// Generic parser to factor error handling out.
  fn generic<
    Out, Error: Display, F: Fn(& str) -> Result<Out, Error>
  >(s: & str, f: F, typ3: & 'static str) -> Result<Out, String> {
    match f(s) {
      Ok(res) => Ok(res),
      Err(e) => Err(
        format!("could not parse \"{}\" as {}: {}", s, typ3, e)
      ),
    }
  }
  /// Parses a [`Bool`](../type.Bool.html).
  pub fn bool(s: & str) -> Result<Bool, String> {
    generic(
      s,
      |s| match s {
        "true" | "on" => Ok(true),
        "false" | "off" => Ok(false),
        _ => Err(
          format!("legal values: true, on, false, off")
        ),
      },
      "a bool"
    )
  }
  /// Parses an [`Int`](../type.Int.html).
  pub fn int(s: & str) -> Result<Int, String> {
    generic(s, |s| Int::from_str(s), "an int")
  }
  /// Parses a [`Real`](../type.Real.html).
  pub fn real(s: & str) -> Result<Real, String> {
    generic(s, |s| Real::from_str(s), "a real")
  }
} */


